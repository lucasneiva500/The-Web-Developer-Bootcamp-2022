<!DOCTYPE html>

<html>

<head>

    <title>HTML + CSS + JS</title>
    <link rel="stylesheet" href=".css">

</head>

<body>

    <nav>
        <a href="">Home</a>
    </nav>

    <main>
        <h1>HTML + CSS + JS</h1>
        <hr>
        <div>
            <h3>intro to the DOM</h3>
            <p>
                DOM = (Document, Object, Model)
                <br>DOM é criado a partir do HTML e do CSS pelo JavaScript
                <br>the DOM is a JavaScript representation of a web page
                <br>it's your JS "window" into the contentes of a webpage
                <br>it's just a bunch of objects that you can interact with via JS
                <br>interações de botões nas páginas
                <br>
                <br>index.html
                <br>app.css
                <br>app.js
                <br>
                <br>Document
                <br>the document object is our entry point into the world of the DOM.
                <br>it contains representations of all the content on a page, plus tons of useful methods and properties
                <br>document, console.dir(document) // comandos nas ferramentas do chrome para inspecionar a página
                <br>(all) contém todos os elementos da página, também acessível por document.all // document.all[index]
                <br>document.all[10].innerText = 'alteração' // permite manipular todo o documento, fazendo alterações por exemplo, inclusive mudar coisas não visíveis como, fontes, estilos etc
                <br>document.dir mostra as características que "representam" o conteúdo que está sendo visto
                <br>
                <br>selecting elements methods
                <br>document.get
                <br>id seleciona um elemento com id específico, tag e class selecionam elementos de um grupo
                <br>getElementById, getElementsbyTagName, getElementsByClassName
                <br>document.getElementbyId('id') // ids que inexistentes retorna null, se existir retorna o elemento com o id
                <br>console.dir(id) // retorna o objeto com todas as suas propriedades
                <br>const nomeVar = getElementById('id') ;; console.dir(nomeVar) // ver todas as propriedades no console
                <br>document.getElementsByTagName('tag') // img, b(bold), p(parágrafo), div, etc
                <br>document.getElementsByClassName('class')
                <br>for (let elements of className) {make changes to all elements of a class in a document by script}
                <br>
                <br>
                <br>querySelector
                <br>querySelector seleciona o primeiro elemento com um ID, classe ou tag
                <br>usa os mesmos seletores de CSS (sintaxe), como seletores descendentes, de classes, etc
                <br>a newer, all-in-one method to select a single element
                <br>document.querySelector('h1'); // Finds first h1 element
                <br>document.querySelector('#red'); // Finds first element with ID of red
                <br>document.querySelector('.big'); // Finds first element with class of
                <br>é possível utilizar múltiplos seletores, por exemplo
                <br>document.querySelector('a[title="Java"]')
                <br>seleciona a anchor tag com o atributo de title = "Java"
                <br>
                <br>querySelectorAll
                <br>document.querySelectorAll('h1'); // Finds all h1 elements
                <br>document.querySelectorAll('#red'); // Finds all elements with ID of red
                <br>document.querySelectorAll('.big'); // Finds all elements with class of
                <br>// href continua o mesmo, só muda a visualização da anchor tag
                <br>
                <br>
                <br>
                <br>
                <br>manipulating elements methods
                <br>using JavaScript to make changes like hiding and showing contents, based on a button for example
                <br>
                <br>properties & methods (the important ones)
                <br>
                <br>classList - lista de classes de um elemento
                <br>getAttribute() - (href) por exemplo, retorna o atributo contido em href
                <br>setAttribute() - ('atr', 'tipoAtr') define um atributo no primeiro argumento e eu tipo no 2
                <br>appendChild() - adiciona o novo elemento como último elemento de um grupo pai
                <br>append() - adiciona algo a um elemento já existente após ele, pode ser mais de um elemento por vez
                <br>prepend() - adiciona algo a um elemento já existente antes dele, pode ser mais de um elemento
                <br>removeChild() - remove o filho de um elemento
                <br>remove() - remove um elemento
                <br>createElement - cria um novo elemento na página
                <br>insertAdjacentElement() - inserção adjacente genéria
                <br>//antes, depois, dentro de um elemento antes ou depois
                <br>
                <br>innerText - texto visível dentro de um marcador(p(parágrafo) por exemplo)
                <br>textContent - todo o conteúdo dentro de um marcador, incluindo conteúdos ocultos
                <br>innerHTML - conteúdo dentro de um marcador, incluindo os códigos de html (&lt;&gt;&lt;/&gt;)
                <br>value - valores dentro de elementos no código JS
                <br>parentElement - element.parentElement // retorna o elemento superior ao escolhido
                <br>childElementCount - indica quantos elementos diretos ele abrange
                <br>children - retorna todos os elementos que estão abrangidos diretamente (index funciona)
                <br>nextSibling - retornam os elementos/nós posteriores ao elemento em questão
                <br>nextElementSibling - retorna o próximo elemento adjacente (do mesmo elemento superior)
                <br>previousSibling - retornam os elementos/nós anteriores ao elemento em questão
                <br>previousElementSibling - retorna o elemento anterior adjacente (do mesmo elemento superior)
                <br>style - configurações "visuais"
                <br>
                <br>
                <br>const allLinks = document.querySelectorAll('a'); // todas as anchor tags
                <br>for (let link of allLinks) {link.innerText = 'i am a link'} // altera o texto das anchor tags
                <br>só muda o texto, não o trata como html
                <br>document.querySelector('h1').innerHTML += '&lt;sup&gt;texto superscrito&lt;/sup&gt;'
                <br>// adiciona um texto superscrito ao primeiro elemento de h1
                <br>
                <br>atributos
                <br>tipos de entrada, id, classes, hrefs, etc são considerados atributos
                <br>document.querySelector('#banner').id = 'whew'
                <br>altera o id do elemento com o id 'banner' para 'whew', e as características do CSS mudam por consequência
                <br>document.querySelector('#id').src
                <br>source do elemento
                <br>.href também pode ser alterado
                <br>
                <br>const firstLink = document.querySelector('a')
                <br>firstLink.href // href de firstLink é o mesmo herdado do primeiro anchor tag
                <br>firstLink.getAttribute('href')
                <br>// retorna o href atribuído ao 'a', herdado por firstLink
                <br>
                <br>const input = document.querySelector('input[type="text"]')
                <br>seleciona o primeiro elemento de input do tipo text
                <br>input.setAttribute('type', 'text')
                <br>define o atributo 'type' para o tipo 'text' da variável 'input'
                <br>
                <br>changing styles
                <br>const h1 = document.querySelector('h1');
                <br>h1.style --- contém todas as propriedades de estilo do código HTML (camelCase)
                <br>//style não mostra as características visuais atribuídas através do CSS
                <br>características precisam conter aspas '' ou ""
                <br>h1.style.color = 'green' --- cor verde em h1, também aceita códigos hexadecimais e rg
                <br>h1.style.fontSize = '3em' --- altera tamanho da fonte em h1
                <br>h1.style.border = '2px solid pink' --- cria uma borda em h1
                <br>textDecorationColor = 'magenta' --- underline color
                <br>textDecorationStyle = 'wavy' --- underline style
                <br>dessa maneira não é possível visualizar a folha de estilos no CSS
                <br>inline styles não são ideais, existe outra maneira de estilizar os elementos, através do JS + CSS
                <br>window.getComputedStyle(h1) --- estilos listados lidos do documento CSS
                <br>window.getComputedStyle(h1).color --- retorna a cor de h1
                <br>window.getComputedStyle(h1).fontSize --- retorna o tamanho da fonte do h1
                <br>fontFamily, marginLeft, margin // propriedades padronizadas pelo browser, CSS padronizado visível
                <br>não é um seletor como os querys por exemplo, é um objeto de elemento real no DOM
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>classList
                <br>manipulação utilizando classes definidas no código em CSS
                <br>
                <br>CSS CONTENT: .purple{color: #7b07ff;} .border {border: 3px solid greenyellow;}
                <br>const h2 = document.querySelector('h2')
                <br>
                <br>atribuições sem classList
                <br>h2.getAttribute('class') // returns null
                <br>h2.setAttribute('class', 'purple') // passa de nenhuma classe para a classe 'purple', escrita roxa
                <br>h2.setAttribute('class', 'border') // deixa de ter o texto roxo para ter uma borda
                <br>
                <br>currentClasses // returns border
                <br>h2.setAttribute('class', `${currentClasses} purple`) // combinar classes purple e border
                <br>
                <br>atribuições com classList
                <br>h2.classList --- lista as classes de h2
                <br>h2.classList.add('purple') --- adiciona a classe 'purple', escrita roxa
                <br>h2.classList.add('border') --- adiciona a classe 'border'
                <br>h2.classList.remove('border') --- remove a classe 'border'
                <br>h2.classList.contains('border') // returns false --- verificar se existe a classe no elemento
                <br>h2.classList.toggle('purple') // retorna true liga/false desl --- liga/desliga a classe purple
                <br>
                <br>for (let element of document.querySelectorAll('li')) {
                <br> element.classList.toggle('highlight');
                <br>}
                <br>// inverte a classe 'highlight' dos elementos listados em uma ul ou ol
                <br>
                <br>
                <br>const novaImg = document.createElement('img')
                <br>// cria um elemento de imagem, porém existem elementos em branco, como source, onde ele fica etc
                <br>novaImg.src = 'https://www.google.com.br/'
                <br>// atribui o source a imagem criada, porém o elemento ainda não está na página
                <br>document.body.appendChild(novaImg)
                <br>// atribui a imagem como o último elemento de body
                <br>novaImg.classList.add('class')
                <br>// adiciona uma classe a imagem criada, classe estilizada do CSS por exemplo
                <br>criar um elemento vazio, e ir adicionando suas características, depois adicioná-lo na página
                <br>
                <br>const h2 = document.createElement('h2')
                <br>h2.append('h2 text') // ou h2.innerText = 'h2 text';
                <br>const h1 = document.querySelector('h1')
                <br>h1.insertAdjacentElement('afterend', h2)
                <br>cria um texto h2 logo após o texto h1
                <br>
                <br>
                <br>removing elementos
                <br>removeChild (método antigo), remove um filho de um elemento, não o elemento selecionado
                <br>varSuperior.removeChild(elemento) // remove o filho
                <br>var.parentElement.removeChild(var) // remove o elemento
                <br>var.remove()
            </p>
            <h3>DOM Events</h3>
            <p>
                Intro to events
                <br>interações entre o usuário quando ele realiza as ações de clicks por exemplo
                <br>clicks, drags, drops, hovers, scrolls, form submission, key presses, focus/blur, mouse wheel, double click, copying, pasting, audio start, screen resize, printing
                <br>
                <br>inline events in HTML (não usar)
                <br>on... , onclick por exemplo, para acontecer algo quando o usuário clicar
                <br>&lt;button onclick="alert('user clicked')"&gt;button&lt;/button&gt;
                <br>
                <br>
                <br>outro método (comum mas não ideal)
                <br>button no HTML com o ID de v2, e linkado com um JS, código em JS:
                <br>const btn = document.querySelector('#v2');
                <br>btn.onclick = function() {console.log('user clicked!')}
                <br>// funções são executadas quando atendem as condições de evento, por exemplo
                <br>function scream() {console.log('screaming!')}
                <br>btn.onmouseenter = scream;
                <br>
                <br>addEventListener (método ideal para usar eventos)
                <br>specify the event type(1st argument) and a callback to run (2nd argument)
                <br>a melhor maneira, pois não acontece erros com sobrescrições, permite mais de uma função
                <br>const button = document.querySelector('#v3');
                <br>button.addEventListener('click', function () {alert('user clicked')})
                <br>button.addEventListener('click', () =&gt; {alert('user clicked')}) // arrow function
                <br>button.addEventListener('click', scream)
                <br>function shout() {console.log('shout')}
                <br>button.addEventListener('click', shout, {once: true})
                <br>// once só funciona uma vez, (once a time)
                <br>
                <br>this pode ser usado para criar funções que seriam repetidas várias vezes em diferentes elementos
                <br>
                <br>
                <br>event object
                <br>é comum nomeá-lo de e,evt,event, nomes fáceis de lembrar
                <br>nas funções de eventos, existe um parâmetro que é passado automaticamente, contendo vários dados
                <br>na função abaixo, (e) é esse elemen adicionado automaticamente, sendo um KeyboardEvent
                <br>const input = document.querySelector('input');
                <br>input.addEventListener('keydown', function (e) {console.log(e.key); console.log(e.code)})
                <br>// code é a posição da letra no teclado, key é o caractere
                <br>
                <br>
                <br>form events
                <br>para não atualizar/reendereçar a página, preventDefault pode ser utilizado
                <br>// preventDefault serve para não realizar a ação padrão do "submit"
                <br>const form = document.querySelector('#idForm');
                <br>form.addEventListener('submit', function (e) {
                <br> e.preventDefault();
                <br> console.log('submited');
                <br> input.value = '';
                <br>})
                <br>// input.value = inserido na input, se for (= '' (string vazia)), é um "reset"
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>document.querySelectorAll('input')[1].value --- informação dentro da segunda input dentro do form
                <br>tweetForm.elements.username.value --- pega o valor da input com o nome de username
                <br>mini formulário de tweet de comentários
                <br>programação em JS:
                <br>
                <br>
                <br>const tweetForm = document.querySelector('#tweetForm');
                <br>const tweetsContainer = document.querySelector('#tweets');
                <br>
                <br>tweetForm.addEventListener('submit', function (e) {
                <br> e.preventDefault();
                <br> const usernameInput = tweetForm.elements.username.value;
                <br> const tweetInput = document.querySelectorAll('input')[1];
                <br> addTweet(usernameInput.value, tweetInput.value)
                <br> usernameInput.value = '';
                <br> tweetInput.value = '';
                <br>});
                <br>
                <br>const addTweet = (username, tweet) =&gt; {
                <br> const newTweet = document.createElement('li');
                <br> const bTag = document.createElement('b');
                <br> bTag.append(username);
                <br> newTweet.append(bTag);
                <br> newTweet.append(`- ${tweet}`);
                <br> console.log(newTweet);
                <br> tweetsContainer.append(newTweet);
                <br>}
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>changeEvent, muda de estado quando desfoca a input por exemplo
                <br>desfoca = clica em outro lugar e deixa de selecionar a input
                <br>addEventListener('change', function (e) {})
                <br>
                <br>inputEvent, envia sempre que ocorre alguma alteração dentro da input, ctrl+v etc
                <br>usar os botões do mouse para colar dados também altera a input
                <br>addEventListener('input', function (e) {})
                <br>
                <br>
                <br>event Bubbling (borbulhamento)
                <br>eventos superiores são acionados em um evento contido em uma seção
                <br>uma seção com onclick contendo um botão com onclick, ambos com alertas, ao clicar no botão acionará os dois eventos
                <br>e.stopPropagation(); --- impede que outros eventos relacionados ao mesmo elemento aconteçam
                <br>
                <br>
                <br>event delegation
                <br>tweetform para adicionar username + tweet como LI em uma UL
                <br>
                <br>tweetsContainer.addEventListener('click', function(e) {
                <br> console.log('CLICK ON UL!')
                <br> console.log(e)
                <br>}) --- código para reconhecer o que está sendo clicado na UL
                <br>
                <br>e.target.remove();
                <br>quando clicar no elemento criado pelo usuário, deletará o "tweet"
                <br>é possível adicionar um botão com essa funcionalidade, mas e.target refere as propriedades
                <br>e.target.nodeName === 'LI' && e.target.remove();
                <br>(se nodeName for LI, deletará a LI selecionada)
            </p>
            <h3>Async JavaScript</h3>
            <p>
                Call Stack
                <br>The mechanism the JS interpreter uses to keep track of its place in a script that calls multiple functions
                <br>How JS "knows" what function is currently being run and what functions are called from within that function, etc
                <br>Uma stack é uma estrutura de dados básica em ciência da computação
                <br>L-I-F-O Data structure, first enter, last leave etc
                <br>
                <br>How it works
                <br>when a script calls a function, the interpreter adds it to the call stack and then starts carrying out the function
                <br>any functions that are called by that function are added to the call stack further up, and run where their calls are reached
                <br>when the current function is finished, the interpreter takes it off the stack and resumes execution where it left off in the last code listing
                <br>faz uma "lista" das funções usadas até chegar em um resultado, então diminui, após isso continua os resultados, até achar um resultado definitivo
                <br>Debugger --- Chrome dev tool para "ver" o call stack funcionando step by step
                <br>é possível colocar breakpoits, pausar a execução, alterar os valores, etc
                <br>
                <br>
                <br>WebAPIs & Single Threaded
                <br>JS is single threaded
                <br>at any given point in time, that single JS thread is running at most one line of JS code
                <br>JavaScript está executando no máximo uma linha de código por vez
                <br>exemplo:
                <br>
                <br>console.log('Sending request to server!')
                <br>setTimeout(() &gt; { console.log('Here is your data from the server...')}, 3000)
                <br>console.log('I AM AT THE END OF THE FILE!') // setTimeout(function, timeInMS)
                <br>
                <br>retorna:
                <br>Sending request to server!
                <br>I AM AT THE END OF THE FILE!
                <br>(depois de 3 segundos) Here is your data from the server...
                <br>
                <br>o browser faz a tarefa enquanto o JavaScript executa o código, o código continua rodando
                <br>browsers come with Web APIs that are able to handle certain tasks in the background (like making requests or setTimeout)
                <br>the JS call stack recognizes these Web API functions and passes them off to the browser to take care of
                <br>once the browser finishes those tasks, they return and are pushed onto the stack as a callback
                <br>os dados são transferidos para o navegador, então o JS continua realizando o código a partir dali, e quando o navegador terminar, ele retorna os valores, e após isso o JS executa o código de maneira apropriada
                <br>Web APIs são as tarefas que estão sendo realizadas pelo navegador enquanto o JS dá continuidade ao código
                <br>
                <br>callback hell
                <br>onde os códigos podem ficar confusos, e muito complexos
                <br>é possível utilizar setTimeout dentro de setTimeout, onde o interno só começa a contar depois de executado o externo
                <br>
                <br>função utilizando setTimeouts dentro de setTimeouts
                <br>const delayedColorChange = (newColor, delay, doNext) =&gt; {
                <br> setTimeout(() =&gt; {
                <br> document.body.style.backgroundColor = newColor;
                <br> doNext && doNext();
                <br> }, delay)
                <br>}
                <br>
                <br>// delayedColorChange('red', 1000, () =&gt; {
                <br> delayedColorChange('orange', 1000, () =&gt; {
                <br> delayedColorChange('yellow', 1000, () =&gt; {
                <br>
                <br> })
                <br> })
                <br>});
                <br>
                <br>searchMoviesAPI('matrix', () =&gt; {
                <br> saveToMyDB(movies, () =&gt; {
                <br> // if it works, run this:
                <br> }, () =&gt; {
                <br> // if it doesn't work, run this:
                <br> }, () =&gt; {
                <br> // if API is down, or request failed
                <br> })
                <br>})
                <br>
                <br>
                <br>váras coisas podem dar errado, credenciais incorretos, sem conexão com internet, com o servidor, etc
                <br>por isso é útil criar uma condição para cada um desses casos
                <br>
                <br>dois callbacks, um se funcionar, e outro se falhar
                <br>makeRequest(() =&gt; {
                <br>
                <br>}, () =&gt; {
                <br>
                <br>})
                <br>mesmo se existir uma condição que depende da primeira tentativa ser bem sucedida, para cada solicitação deve ter uma condição para funcionar, e uma para não funcionar, por isso callback hell se torna confuso a medida que muitas solicitações são dependentes
                <br>
                <br>
                <br>
                <br>
                <br>enter promises --- método mais recente para ajudar ao invés de escrever "callback hells"
                <br>a promise is an object representing the eventual completion or failure of an asynchronous operation
                <br>PromiseStatus: pending (initial state, not solved yet), resolved (success) and rejected (failure)
                <br>é possível fazer uma função rodar quando o status for resolvido, ou rejeitado
                <br>a promise is a returned object to which you attach callbacks, instead of pasting callbacks into a function
                <br>
                <br>base func
                <br>const fakeRequestPromise = (url) =&gt; {
                <br> return new Promise ((resolve, reject) =&gt; {
                <br> const delay = Math.floor(Math.random() * (4500)) + 500;
                <br> setTimeout (() =&gt; {
                <br> if (delay &gt; 4000) {
                <br> reject('Connection timeout :(')
                <br> } else {
                <br> resolve(`Here ir your fake data from ${url}`)
                <br> }
                <br> }, delay)
                <br> })
                <br>}
                <br>
                <br>creating promise func
                <br>new Promise ((resolve, reject) =&gt; {
                <br> // resolve('Resolved!'); or reject('Rejected!');, or will sting pending
                <br>})
                <br>
                <br>função com Promise, seguindo a lógica de callback hells
                <br>fakeRequestPromise('yelp.com/api/coffee/page1')
                <br> .then(() =&gt; {
                <br> console.log('PROMISE RESOLVED!!!')
                <br> fakeRequestPromise('yelp.com/api/coffee/page2')
                <br> .then(() =&gt; {
                <br> console.log('PROMISE RESOLVED (2)!!!')
                <br> })
                <br> .catch (() =&gt; {
                <br> console.log('PROMISE REJECTED (2)!!!')
                <br> })
                <br> }).catch (() =&gt; {
                <br> console.log('PROMISE REJECTED (1)!!!')
                <br> })
                <br>// .then run function when request promise is resolved
                <br>// .catch run function when request promise is rejected
                <br>// methods for promises, only one will run
                <br>
                <br>
                <br>magic promise, using one catch for all subsequence errors, completely more flat
                <br>fakeRequestPromise('yelp.com/api/coffee/page1')
                <br> .then((data) =&gt; {
                <br> console.log('PROMISE RESOLVED!!!')
                <br> return fakeRequestPromise('yelp.com/api/coffee/page2')
                <br> console.log(data)
                <br> })
                <br> .then ((data) =&gt; {
                <br> console.log('PROMISE RESOLVED (2)!!!')
                <br> console.log(data)
                <br> return fakeRequestPromise('yelp.com/api/coffee/page2')
                <br> })
                <br> .then ((data) =&gt; {
                <br> console.log('PROMISE RESOLVED (3)!!!')
                <br> console.log(data)
                <br> })
                <br> .catch((err) =&gt; {
                <br> console.log('OH NO, A REQUEST FAILED!')
                <br> console.log(err)
                <br> })
                <br>// se qualquer then falhar, será redirecionado para o catch, informando o erro
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>async functions (async await)
                <br>a newer and cleaner syntax for working with async code!
                <br>syntax "makeup" for promises
                <br>
                <br>
                <br>the async keyword
                <br>async functions always return a promise
                <br>if the function returns a value, the promise will be resolved with that value
                <br>if the functions throws an exception, the promise will be rejected
                <br>async can be an arrow function [const asyncFunc = async () =&gt; {console.log('hi!')}]
                <br>
                <br>async function hello() {
                <br>return 'Hey guy!';
                <br>}
                <br>hello (); // Promise {&lt;resolved&gt;: "Hey guy!"}
                <br>async function uhOh () {
                <br> throw new Error('oh no!')
                <br>}
                <br>uhOh; // Promise {&lt;rejected&gt;: Error: oh no!}
                <br>
                <br>
                <br>const sing = async () =&gt; {
                <br> // throw 'OH NO, PROBLEM!' --- reject promise
                <br> return 'singing'
                <br>}
                <br>
                <br>sing()
                <br> .then(data =&gt; {
                <br> console.log('PROMISE RESOLVED WITH:', data)
                <br> })
                <br> .catch(err =&gt; {
                <br> console.log('PROMISE REJECTED!')
                <br> console.log(err)
                <br> }
                <br>
                <br> // throw new Error('ERROR MESSAGE!')
                <br>
                <br>outro exemplo
                <br>const login = async (username, password) =&gt; {
                <br> if(!username || !password) throw 'Missing Credentials'
                <br> if(password === '123') return 'WELCOME!'
                <br> throw 'Invalid Password'
                <br>}
                <br>
                <br>login('luc', '123')
                <br> .then (msg =&gt; {
                <br> console.log('LOGGED IN!')
                <br> console.log(msg)
                <br> })
                <br> .catch(err =&gt; {
                <br> console.log('ERROR!')
                <br> console.log(err)
                <br>})
                <br>
                <br>
                <br>the await keyword
                <br>we can only use correctly the await keyword inside of functions declared with async
                <br>await will pause the execution of the function, waiting for a promise to be resolved
                <br>
                <br>async function rainbow() {
                <br> await delayedColorChange('red', 1000)
                <br> await delayedColorChange('green', 1000)
                <br> await delayedColorChange('blue', 1000)
                <br> return 'Finished!'
                <br>}
                <br>// as linhas debaixo só rodam quando a promise da linha de cima for resolvida
                <br>
                <br>async function printRainbow() {
                <br> await rainbow();
                <br> console.log('END OF RAINBOW!')
                <br>}
                <br>
                <br>async function makeTwoRequests () {
                <br> let data1 = await fakeRequestPromise('/page1');
                <br> console.log(data1);
                <br>}
                <br>se uma promise dentro do await for rejeitada, a execução do código irá parar ali
                <br>
                <br>async function makeTwoRequests () {
                <br> try {
                <br> let data1 = await fakeRequestPromise('/page1');
                <br> console.log)(data1);
                <br> let data2 = await fakeRequestPromise('/page2');
                <br> console.log(data2);
                <br> } catch (e) {
                <br> console.log('CAUGHT AN ERROR!')
                <br> console.log('error is:', e)
                <br> }
                <br>}
            </p>
            <h3>AJAX and API's</h3>
            <p>
                AJAX (Asynchronous JavaScript And XML) - antigo
                <br>XML é parecido com HTML:
                <br>&lt;Products&gt;
                <br> &lt;Product&gt;
                <br> &lt;Code&gt;291&lt;/code&gt;
                <br> &lt;StockQty&gt;10&lt;/StockQty&gt;
                <br> &lt;/Product&gt;
                <br> &lt;Product&gt;
                <br> &lt;Code&gt;277&lt;/Code&gt;
                <br> &lt;StockQty&gt;8&lt;/StockQty&gt;
                <br> &lt;/Product&gt;
                <br>&lt;/Products&gt;
                <br>
                <br>
                <br>AJAJ (Asynchronous JavaScript And JSON) - atual
                <br>fazer solicitações na página enquanto ela está sendo carregada ou quando já foi carregada
                <br>solicitações, salvar, carregar, aplicação que armazena dados ou resulta em dados quando solicitados
                <br>F12 (Chrome dev tools) aba Network mostra as solicitações que são feitas na página atual
                <br>
                <br>
                <br>APIs (Application Programming Interface)
                <br>comunicação entre softwares, não necessariamente relacionado a alguma coisa da web
                <br>Web APIs
                <br>interfaces baseadas em WEB e HTTP (interface que ocorre por HTTP)
                <br>WebAPI preço do bitcoin em dólar --- https://api.cryptonator.com/api/ticker/btc-usd
                <br>twilio --- API com serviço de envio de mensagens no celular, ligações programadas, etc
                <br>
                <br>(formato usado antigamente para API era o XML - eXtensible Markup Language / AJAX)
                <br>JSON (Java Script Object Notation - formato de API atual / AJAJ)
                <br>escrita em JSON, similar a sintaxe do JavaScript, baseado em objetos do JavaScript, mas existem diferenças importantes
                <br>cada key deve ser uma string com aspas ("string"), apóstrofo é inválido ('string')
                <br>
                <br>{
                <br> "squadName": "Charlie",
                <br> "formed": 2016,
                <br> "active": true,
                <br> "members": [
                <br> "Joe",
                <br> "Carl",
                <br> "Max"
                <br> ]
                <br>}
                <br>APIs em JSON podem ser usadas em outras linguagens de programação, como Python, Java, Ruby, etc
                <br>é necessário validar no JavaScript que a API está no formato JSON, se não ele transforma todos os dados em uma única string
                <br>
                <br>JSON.parse(text[, reviver])
                <br>const dataJSON = `{"ticker":{"base":"BTC","target":"USD","price":"42810.79836584","volume":"23717.22875318","change":"2.44920687"},"timestamp":1642100043,"success":true,"error":""}`
                <br>(https://api.cryptonator.com/api/ticker/btc-usd)
                <br>const parsedData = JSON.parse(dataJSON)
                <br>parsedData.ticker.price
                <br>// retorna o valor do bitcoin em dólar
                <br>
                <br>também é possível transformar um objeto em JavaScript em JSON usando o método
                <br>JSON.stringify(objectDataJavaScript)
                <br>JSON.stringify(value[, replacer[, space]])
                <br>útil para enviar informações para uma API
                <br>todos os valores que estão como undefined são sobrescritos com null, e tipos não suportados são censurados
                <br>the replacer option allows for specifying other behavior
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>Postman
                <br>maneira "simplificada" de fazer solicitações em APIs
                <br>ferramenta de depuração para auxiliar na hora de solicitar uma API
                <br>(https://api.cryptonator.com/api/full/btc-usd) BTC Markets
                <br>Status (HTTP response status codes):
                <br>Rápido indicador do que aconteceu ao carregar/ou tentar carregar a URL
                <br>1. Informational responses (100-199)
                <br>2. Sucessful responses (200-299)
                <br>3. Redirects (300-399)
                <br>4. Client errors (400-499)
                <br>5. Server errors (500-599)
                <br>404 Not Found - dados não foram encontrados
                <br>405 Not Allowed - não permitido fazer a operação, incompatível com o recurso
                <br>visíveis na aba network do chrome dev tools, importante na aquisição de dados no postman
                <br>Operações:
                <br>GET - obtem os dados fornecidos através da URL inserida
                <br>POST - enviar dados na URL inserida
                <br>
                <br>Body
                <br>contém as informações da página, independente do tipo de linguagem que está sendo exibido
                <br>
                <br>Headers
                <br>key-value pairs, são tipo uma metadata da resposta e da solicitação
                <br>content-type - application/json --- formato em JSON
                <br>content-type - text/html --- formato em HTML
                <br>
                <br>query strings e headers
                <br>sempre que tiver dois pontos (shows?q=:query) em uma URL de API, significa que é uma variável
                <br>(?q=) question mark singifica que é uma query string
                <br>(https://www.google.com/search) site de consulta padrão (https://www.google.com/search?q=aaa) site de consulta especificando o que está sendo procurando utilizando a query string mais a variável inserida, que será exibida
                <br>query strings são informações fornecidas ao URL, geralmente impactando no que é exibido de volta
                <br>querystring1=a&querystring2=b, se uma das query strings não forem reconhecidas, ela será ignorada, o & une mais de uma no mesmo URL
                <br>na opção de Params ao digitar um URL fonte no Postman, é possível digitar os pares key-value sem precisar se preocupar com a formatação no URL
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>XMLHttpRequest - Método original de fazer solicitações
                <br>the original way of sending requests via JS
                <br>does not support promises, so...lots of callbacks!
                <br>WTF is going on with the weird capitalization?
                <br>clunky sintax that i find difficult to remember
                <br>
                <br>const myReq = new XMLHttpRequest();
                <br>
                <br>myReq.onload = function() {
                <br> const data = JSON.parse(this.responseText);
                <br> console.log(data);
                <br>};
                <br>myReq.onerror = function(err) {
                <br> console.log('ERROR!', err);
                <br>};
                <br>myReq.open('get', 'https://icanhazdadjoke.com', true);
                <br>myReq.setRequestHeader('Accept', 'application/json');
                <br>myReq.send();
                <br>// cria uma solicitação, onload é se for bem sucedida, onerror se acontecer um erro
                <br>// open('método', 'url') método = get, post, etc
                <br>
                <br>
                <br>Fetch API - maneira mais recente de fazer solicitações utilizando JavaScript
                <br>the newer way of making requests via JS, based on using promises
                <br>supports promises!
                <br>not supported in internet explorer :(
                <br>
                <br>fetch('api.cryptonator.com/api/ticker/btc-usd') // return a promise, use GET by default
                <br> .then(res =&gt; {
                <br> console.log('RESPONSE', res)
                <br> })
                <br> .catch(e =&gt; {
                <br> console.log('ERROR!', e)
                <br> })
                <br>
                <br>fetch resolve automaticamente a promise assim que receber o primeiro bit do URL inserido
                <br>para isso é usado um segundo método chamado .JSON
                <br>
                <br>return res.json()
                <br>fetch('api.cryptonator.com/api/ticker/btc-usd') // return a promise, use GET by default
                <br> .then(res =&gt; {
                <br> console.log('RESPONSEN WAITING TO PARSE...', res)
                <br> return res.json()
                <br> })
                <br> .then(data =&gt; {
                <br> console.log('DATA PARSED...', data)
                <br> console.log(data.ticker.price)
                <br> })
                <br> .catch(e =&gt; {
                <br> console.log('ERROR!', e)
                <br> })
                <br>
                <br>outra maneira de fazer a mesma operação usando async func, melhorada e mais compacta
                <br>
                <br>const fetchBitcoinPrice = async () =&gt; {
                <br> try {
                <br> const res = await fetch('api.cryptonator.com/api/ticker/btc-usd')
                <br> const data = await res.json();
                <br> console.log(data.ticker.price)
                <br> } catch(e){
                <br> console.log('SOMETHING WENT WRONG!', e)
                <br> }
                <br>}
                <br>
                <br>
                <br>Axios
                <br>biblioteca externa que ajuda a usar APIs
                <br>REPOSITÓRIO NO GITHUB --- https://github.com/axios/axios
                <br>PÁGINA DO AXIOS --- https://axios-http.com/docs/intro
                <br>a library for making http requests, make it easier
                <br>sem o axios, apenas com o fetch é preciso usar res.json() para esperar uma promise antes de coemeçar outra, tornado assim um processo de duas etapas, com o axios é possível fazer utilizando uma etapa
                <br>existem várias maneiras de incluir a biblioteca do axios no código
                <br>a mais simples é adicionar utilizando os links na página do repositório,
                <br>"Using jsDelivr CDN:"
                <br>ou
                <br>"Using unpkg CDN:"
                <br>é comum utilizar esse script no final de &lt;/head&gt;, pois são scripts externos
                <br>é crucial colocar antes do app.js programado
                <br>
                <br>métodos utilizando axios
                <br>axios é uma biblioteca que funciona junto com JS no lado do cliente
                <br>Node.JS é usado no lado do servidor onde é possível manipular bibliotecas, instalar, importar etc
                <br>usando axios, a promise só é resolvida quando tudo termina, sem precisar usar awaits, etc
                <br>
                <br>const axios = require('axios'); // não necessário
                <br>axios.get('/user?ID=12345')
                <br> .then (function (response) {
                <br> // handle success
                <br> console.log(response);
                <br> })
                <br> .catch (function (error) {
                <br> // handle error
                <br> console.log(error);
                <br> })
                <br> .then(function () {
                <br> // always executed
                <br> });
                <br>
                <br>axios.get('api.cryptonator.com/api/ticker/btc-usd')
                <br> .then(res =&gt; {
                <br> console.log(res.data.ticker.price)
                <br> })
                <br> .catch(err =&gt; {
                <br> console.log('ERROR!', err)
                <br> })
                <br>
                <br>é possível utilizar async func junto com axios
                <br>const fetchBitcoinPrice = async () =&gt; {
                <br> try {
                <br> const res = await axios.get('api.cryptonator.com/api/ticker/btc-usd')
                <br> console.log(res.data.ticker.price)
                <br> } catch(e) {
                <br> console.log('ERROR!', e)
                <br> }
                <br>}
                <br>
                <br>setting headers with axios
                <br>
                <br>const getDadJoke = async () =&gt; {
                <br> const config = { headers: { Accept: 'application/json' } }
                <br> const res = await axios.get('https://icanhazdadjoke.com/, config')
                <br> console.log(res.data.joke)
                <br>}
                <br>
                <br>
                <br>
                <br>Atualização de Dezembro de 2022 - API e HTTP
                <br>Hoppscoth - aplicativo similar ao postman, used to send request in sites
                <br>Open source completely free, a alternative in case of troubles to installing postman, test APIs
                <br>https://swapi.dev/ - all star wars information in site to test APIs, returning HTML as response, or JSON
                <br>apps postman and hoppscoth, helps to know APIs workflow
                <br>
                <br>
                <br>HTTP verbs
                <br>Is important to understando the verbs to use APIs, create APIs and test APIs functionalities
                <br>GET - GET or retrieve information, is the most used, for example to load web pages
                <br>POST - POST or sending data to urls to store data in databases, for example
                <br>DELETE - DELETE something, use to delete data in databases, for example
                <br>
                <br>
                <br>HTTP Status Codes
                <br>https://developer.mozilla.org/en-US/docs/Web/HTTP/Status - client side responses of HTTP errors in server side
                <br>is used to create some responsive error pages in case of debugging this types of errors
                <br>is used to make error pages, in case of 404 not found
                <br>405 method not allowed in case to trying to use another verbs in case of APIS, error pages for this too, for example
                <br>server side errors
                <br>
                <br>
                <br>Query Strings
                <br>https://swapi.dev/documentation - SWAPI API documentation
                <br>is important know how the API work, in case of this star wars API, have all the documentation to read
                <br>this is a manual to use verbs, and type of information the user will retrieve in client side
                <br>?sort=desc&color=blue - for example, is in end of url site, to sort desc things have the blue color
                <br>/watch?v=89NeyF8qTIg - youtube, ?v= id of the video, retrieving the information to user
                <br>search results is using this query strings in different categories of search, defined in the developing server side
                <br>in apps postman and hoppscoth, the query parameters can be defined, to make easier longs urls using different types of search
                <br>
                <br>
                <br>HTTP Headers
                <br>in chrome developer tools in network, the headers of responses and HTTP status codes load when user make a request in a url
                <br>the folder "6 Dad Joke" is using this type of request methods in APIs
                <br>
                <br>
                <br>HMLHttpRequest
                <br>is the original way of sending requests via JS
                <br>code to make a XMLHttpRequest object in JS
                <br>
                <br>const req = new XMLHttpRequest();
                <br>req.onload = function() {
                <br>console.log("IT LOADED!!!");
                <br>console.log(this);
                <br>}
                <br>req.onerror = function () {
                <br>console.log("ERROR!!!");
                <br>console.log(this);
                <br>}
                <br>req.open("GET", "https://swapi.dev/api/people/1/");
                <br>req.send();
                <br>
                <br>req.onload to get specific informations of the JS object
                <br>const data = JSON.parse(this.responseText);
                <br>console.log(data.name, data.height);
                <br>
                <br>
                <br>Fetch API
                <br>the newer way of making requests via JS
                <br>
                <br>fetch("https://swapi.dev/api/people/1/");
                <br>retuns a promise
                <br>fetch("https://swapi.dev/api/people/1/").then(res =&gt; { console.log("RESOLVED!", res);}).catch(e =&gt; { console.log("ERROR!", e);});
                <br>retun the headers, status code, and the body, the most confusing part of fetch
                <br>this response body not include all information we might expect it to, because the promise is resolved as soon as fetch receives any headers
                <br>that means, it may not have the full body, all the JSON, all the information before it resolved
                <br>fetch("https://swapi.dev/api/people/1/").then(res =&gt; { console.log("RESOLVED!", res); res.json().then((data) =&gt; console.log("JSON DONE!", data))}).catch(e =&gt; { console.log("ERROR!", e);});
                <br>
                <br>
                <br>Axios
                <br>A library for making HTTP Requests, using fetch, but the most simple way to doing this requests
                <br>https://github.com/axios/axios - documentation
                <br>including the axios script in the html document whit app.js
                <br>axios have this methods, for making the http requests
                <br>
                <br>const getStarWarsPerson = async (id) =&gt; {
                <br>try {
                <br> const res = await.axios.get(`https://swapi.dev/api/people/${id}/`);
                <br> console.log(res.data);
                <br> } catch(e){
                <br> console.log("ERROR!!!", e);
                <br> }
                <br>};
                <br>
                <br>dont need the extra part, parsing the object to make it whit all informations
                <br>axios detailed things is described along information, before the december 2022 update
            </p>
            <h3>Prototypes, Classes e OOP</h3>
            <p>
                Prototypes __proto__
                <br>agrupa todos os métodos de um objeto, é uma propriedade que "lista os métodos", inclusive os criados
                <br>os métodos de um objeto não é criado no objeto, é criado no protótipo do objeto
                <br>Array.prototype = lista todas as funções do protótipo de uma array, por exemplo, é um modelo que toda array terá, pois cada um tem sua referência do prototype e compartilham os mesmos métodos
                <br>String.prototype, mostra todos os string methods, etcs
                <br>String.prototype.awayyy = () =&gt; alert('Go away!')
                <br>cria uma propriedade para todas as strings que ao ser chamada, cria um alerta
                <br>const cat = 'blue';
                <br>cat.awayyy --- gera um alerta
                <br>se um método criado tiver o mesmo nome que um método padrão, o método padrão será sobrescrito
                <br>'hi'.slice == 'bye'.slice // retorna true, os métodos são iguais e ainda não foram definidos nas strings, eles não tem suas próprias cópias, eles se referenciam ao protótipo de strings
                <br>
                <br>OOP (Object-Oriented Programming)
                <br>ideia principal de organizar o código, projetar e estruturar dividindo as coisas em padrões distintos
                <br>hsl(180,50%,30%) --- hsl color system hsl(0-360,%,%) // rgb, rgba, hexadec #FFFFFF, hsl
                <br>para achar a cor oposta em hsl, é só adicionar 180 ao hue
                <br>
                <br>
                <br>factory functions (não muito comum)
                <br>
                <br>function funcName(a, b, c) {
                <br> const propertyName = {};
                <br> propertyName.a = a;
                <br> propertyName.b = b;
                <br> propertyName.c = c;
                <br> propertyName.abc = function() {
                <br> const { r, g, b } = this;
                <br> return `abc(${a}, ${b}, ${c}`;
                <br> };
                <br> return propertyName
                <br>}
                <br>se usar a expressão
                <br>const funcTest = funcName(10, 20, 30)
                <br>para alterar algum valor em funcTest é possível utilizando
                <br>funcTest.a = 2
                <br>
                <br>
                <br>constructor functions (comum)
                <br>new --- operador
                <br>new em constructor funcs cria um objeto e o retorna no final de maneira implícita
                <br>não usar arrow functions com new, pois em arrow functions o "this" se comporta de maneira diferente, podendo gerar erros inesperados
                <br>iniciais maíusculas indicam constructor functions e classes
                <br>
                <br>function FuncName (a, b, c) {
                <br> this.a = a;
                <br> this.b = b;
                <br> this.c = c;
                <br> console.log(this);
                <br>}
                <br>// a função sem utilizar o operador new, se refere a janela com a expressão this
                <br>
                <br>new FuncName(1, 2, 3)
                <br>cria um objeto, e define os valores Color.a = 1, Color.b = 2, Color.c = 3, etc
                <br>torna essa operação feita de uma maneira mais compacta
                <br>
                <br>FuncName.prototype.abc = function () {
                <br> const { a, b, c} = this;
                <br> return `abc(${a}, ${b}, ${c}`;
                <br>}
                <br> // cria um método no protótipo para as variáveis que forem definidas com FuncName
                <br>FuncName.prototype.methodName = function() {
                <br> function using "this"
                <br>}
                <br>
                <br>const abc = FuncName(1, 2, 3);
                <br>abc.abc
                <br>const abc2 = FuncName(4, 5, 6);
                <br>abc2.abc
                <br> // abc2 método abc é definido em __proto__
                <br>
                <br>constructor functions é mais útil pois não é necessário criar os métodos para cada elemento que for adicionado utilizando a função usada com new, já que os métodos ficam em __proto__
                <br>abc.abc === abc2.abc // retorna true, pois as funções são iguais, ambas no protótipo
                <br>
                <br>
                <br>JavaScript classes (ideal)
                <br>sintaxe nova para reescrever factory/constructor functions
                <br>criar um "template" para adicionar os métodos ao protótipo
                <br>não é necessário criar a função de forma separada depois adicionar os métodos
                <br>é a maneira mais compacta de fazer
                <br>
                <br>class FuncName {
                <br> constructor(a,b,c) {
                <br> this.a = a;
                <br> this.b = b;
                <br> this.c = c;
                <br> }
                <br> abc() {
                <br> const { a, b, c } = this;
                <br> return `abc(${a}, ${b}, ${c}`;
                <br> }
                <br> hslOpposite() {
                <br> const { h, s, l } = this;
                <br> const newHue = (h + 180) % 360;
                <br> return `hsl ${newHue}, ${s}, ${l}`;
                <br> }
                <br>}
                <br>// constructor é a função que será executada imediatamente assim que um FuncName for criado
                <br>// os métodos são definidos por funcName(){}
                <br>// os métodos também são adicionados ao protótipo __proto__
                <br>
                <br>const c1 = new FuncName(255, 67, 89);
                <br>
                <br>
                <br>extends and super keywords
                <br>
                <br>extends
                <br>class Cat {
                <br> constructor(name, age) {
                <br> this.name = name;
                <br> this.age = age;
                <br> }
                <br> eat() {
                <br> return `${this.name} is eating!`;
                <br> }
                <br> meow() {
                <br> return 'meow';
                <br> }
                <br>}
                <br>
                <br>class Dog {
                <br> constructor(name, age) {
                <br> this.name = name;
                <br> this.age = age;
                <br> }
                <br> eat() {
                <br> return `${this.name} is eating!`;
                <br> }
                <br> bark() {
                <br> return 'wolf';
                <br> }
                <br>}
                <br>// apesar de bark() e meow(), todas as outras funcionalidades são duplicadas
                <br>// para resolver é necessário criar uma nova classe com as funcionalidades que estão duplicadas
                <br>// e as funcionalidades únicas inseridas sem o elemento constructor nas funçõs como:
                <br>// FuncNameAdd extends FuncName { function }
                <br>
                <br>class Pet {
                <br> constructor(name, age) {
                <br> this.name = name;
                <br> this.age = age;
                <br> }
                <br> eat() {
                <br> return `${this.name} is eating!`;
                <br> }
                <br>}
                <br>
                <br>class Cat extends Pet {
                <br> meow() {
                <br> return 'meow';
                <br> }
                <br>}
                <br>
                <br>class Dog extends Pet {
                <br> bark() {
                <br> return 'wolf';
                <br> }
                <br>}
                <br>
                <br>const wyatt = new Dog('Wyatt', 13)
                <br>wyatt.eat()
                <br>
                <br>// extends adiciona todas os métodos da classe selecionada, e adiciona os que serão inseridos
                <br>// cria um __proto__ de Pet com as funcionalidades dentro do __proto__ de Dog
                <br>// se existir uma funcionalidade em Dog com o mesmo nome que uma funcionalidade, a que funcionará é a de Dog, pois a de Pet é sobrescrita, somente funciona a de Pet se a funcionalidade não estiver definida em Dog
                <br>
                <br>super
                <br>se for necessário uma informação adicional em Cat, é possível utilizar super para não repetir vários "this"
                <br>
                <br>class Pet {
                <br> constructor(name, age) {
                <br> this.name = name;
                <br> this.age = age;
                <br> }
                <br> eat() {
                <br> return `${this.name} is eating!`;
                <br> }
                <br>}
                <br>
                <br>class Cat extends Pet {
                <br> constructor(name, age, livesLeft = 7) {
                <br> super(name,age)
                <br> this.livesLeft = livesLeft;
                <br> }
                <br> meow() {
                <br> return 'meow';
                <br> }
                <br>}
                <br>
                <br>class Dog extends Pet {
                <br> bark() {
                <br> return 'wolf';
                <br> }
                <br>}
                <br>
                <br>// agora Cat tem a propriedade livesLeft, que se não for definida tem o valor padrão de 7
                <br>// super(var,var2,var3) referencia a variável junto ao extends, como se fosse vários (this.var = var;)
            </p>
            <h3>Mastering the Terminal</h3>
            <p>
                Introduction to backend concept
                <br>Criação de servidores, conexão com banco de dados
                <br>
                <br>Terminal
                <br>terminal != shell, command line, console, bash (tem a mesma ideia mas não são a mesma coisa)
                <br>Terminal = a text-based interface to your computer. originally a physical object, but now we use software terminals
                <br>Shell = the program running on the terminal
                <br>Bash = one of the most popular shells (and the default on a mac), z shell is other
                <br>reasons to use
                <br>1 = speed (develop faster) - the terminal takes some getting used to, but it can be MUCH faster than nusing a GUI
                <br>2 = access (with great power...) - the terminal provides a "mainline" into the heart of our computer, giving us access to areas we normally don't interact with.
                <br>3 = Tools! - many of the tools we need are installed and used via the command line. We don't have much of a choice!
                <br>Windows machines doesn't have a default terminal, need to install
                <br>Actually using Git Bash Installer (ver Git-2.34.1-64-bit)
                <br>
                <br>Usando o terminal, comandos, etc
                <br>Quando o terminal é aberto, é como se estivesse dentro de uma pasta
                <br>home directory - C:\Users\lucas
                <br>
                <br>"mkdir folderNameUP/folderNameDOWN folderName2" --- cria três pastas, sendo que a DOWN está em UP
                <br>"mkdir ../folderName" --- cria uma pasta no diretório acima do atual
                <br>não é possível criar uma pasta já existende com o comando mkdir
                <br>a tecla TAB faz autopreenchimento em navegação de diretórios usando "cd"
                <br>'~' referencia o home directory
                <br>clear - limpa o terminal, mantendo o diretório
                <br>stat - lista informações sobre o arquivo "stat fileName"
                <br>
                <br>Relative Paths ("cd ../../..") vs Absolute Paths ("cd /../../..")
                <br>caminho relativo é o caminho atual do terminal, e possibilidade de somente avançar e retroceder do diretório atual
                <br>caminho absoluto define o diretório "alvo", independente do diretório atual, começando com /
                <br>
                <br>man pages and flags (alguns são comandos indisponíveis no git bash)
                <br>help (documentação) - "command --help", mostra as informações de um comando
                <br>rmdir (remove directory) - "rmdir folderName", apaga um diretório
                <br>
                <br>comandos indisponíveis no git bash, disponíveis no terminal BASH, de usuários MAC
                <br>man (manual) - mostra a documentação de um comando (man commandName)
                <br>q (quit) - sai da página de documentação do manual
                <br>ls -l (long info) - "command -l", mostra informações adicionais para o comando, exemplo ls -l
                <br>ls -a (hidden files) - "command -a", mostra arquivos ocultos, ls -a por exemplo
                <br>mkdir -v (detailed info) - "command -v", mostra informações detelhadas, mkdir -v folderName1 folderName2
                <br>rm -rf (remover!) - r(recursive) f(force), "rm -rf folderName" apaga pasta e todos os arquivos PRA SEMPRE!
                <br>cd \ - para usar o cd em pastas com espaços no nome, basta utilizar a barra invertida antes do espaço "cd Application\ Support/" - nome da pasta "Application Support"
                <br>
                <br>CD LS MKDIR PWD RM Touch
                <br>LS (List) - lista todo o conteúdo do diretório atual (pastas etc)
                <br>PWD (Print Work Directory) - mostra qual o diretório atual
                <br>CD (Change Directory) - troca de diretório, (cd directoryName) para voltar, "cd .."
                <br>MKDIR (Make Directory) - cria uma pasta (ou várias) no diretório atual "mkdir folderName fN2"
                <br>Touch (Create files) - cria um ou vários arquivos com a extensão inserida "touch index.html" (ou modifica o acesso e o tempo de arquivos já existentes "touch -d "YYYY-MM-DD HH:mm" fileName")
                <br>RM (Remove) - deleta arquivos "rm folderName.extensions" (não vai pra lixeira, apaga)
            </p>
            <h3>First brush with node</h3>
            <p>
                introducting the Node.js
                <br>Node.js is a JavaScript runtime, until recently, we could only run JavaScript in a web browser, Node is a JavaScript runtime that executes code outside of the browser. We can use the same JavaScript syntax we know and love to write server-side code, instead of relying on other languages, like Python or Ruby.
                <br>implementação do JavaScript para rodar código fora do navegador
                <br>WebServers, Command Line Tools, Native Apps (VSCode is a Node app!), Video Games, Drone Software, and a whole lot more is build in Node.js
                <br>
                <br>usand Node.js
                <br>é necessário instalar o node.js, e após instalá-lo o comando node fica disponível no terminal
                <br>para sair do comando node no Git Bash, o atalho é "Ctrl + D" ou o texto ".exit"
                <br>ao ser adicionado um comando no node, ele executa o ciclo REPL (Read–Eval–Print Loop)
                <br>Node REPL fica em loop continuo, diferente de HTML, CSS e JS, como void loop em arduino
                <br>ao entrar no node, é como se estivesse no console de JavaScript de um browser
                <br>
                <br>Node.js VS Client-Side js
                <br>not included in node = because Node.js does not run in a browser, we don't have access to all the browser "stuff". The window, document, and DOM API's are not a thing in Node.js!
                <br>new stuff in node = Node.js comes with a bunch of built-in modules that don't exist in the browser. These modules help us do things like interact with the operating system and files/folders.
                <br>no browser, window é o elemento global, o nível superior de tudo (escopo global)
                <br>o escopo global em Node.js é chamado de "global"
                <br>
                <br>Arquivos em Node.js são escritos no VSCode exatamente como JavaScript, utilizando a extensão .js
                <br>é possível executar um arquivo Node.js utilizando "node fileName.js" no terminal
                <br>se houver algum erro, ele aponta o que está sendo o erro
                <br>(é necessário o arquivo estar no mesmo diretório atual do terminal, ou ser indicado "node ../.js")
                <br>
                <br>Node.js tem uma imensidão de funcionalidades, o curso abrange só o básico para webdevelopment
                <br>é possível ver a documentação no site do Node.js na aba Docs, ao selecionar a versão
                <br>utilizando a (v16.13.2) - 19/01/2022, no terminal é só utilizar o comando "node -v"
                <br>('node / process.version / process.release') - versão específica do Node.js
                <br>process.cwd() --- diretório atual, onde o Node.js está sendo executado
                <br>process.argv --- dentro do node só da um resultado, diferente de executado a partir de um arquivo.js
                <br>é possível adicionar argumentos na array argv utilizando "node args.js argument1 2 3"
                <br>( const args = process.argv.slice(2); for (let arg of args) { console.log(`Hi,${arg}`) } ) - arg.js
                <br>o slice serve para não contar os dois primeiros elementos, (0 = node; 1 = args.js)
                <br>
                <br>
                <br>file system module crash course
                <br>template creator - cria uma pasta com o nome de inserido, e dentro dela index.html, app.css e app.js
                <br>sync methods --- faz a ação e espera até a ação terminar para prosseguir, bloqueia outros códigos
                <br>async methods --- faz várias ações de uma vez, não útil para criar pastas dentro de pastas por ex
                <br>
                <br>
                <br>const fs = require('fs'); --- adiciona o método para o programa
                <br>const folderName = process.argv[2] || 'Project'
                <br>
                <br>try {
                <br> fs.mkdirSync(folderName);
                <br> fs.writeFileSync(`${folderName}/index.html`)
                <br> fs.writeFileSync(`${folderName}/styles.css`)
                <br> fs.writeFileSync(`${folderName}/app.js`)
                <br> } catch (e) {
                <br> console.log('Something went wrong!');
                <br> console.log(e);
                <br>}
            </p>
            <h3>Exploring Modules & The NPM Universe</h3>
            <p>
                working with module.exports
                <br>é possível adicionar métodos de um arquivo escrito em JS
                <br>os "métodos" exportados podem ser objetos, valores, strings, funções, etc
                <br>os métodos que serão exportados são definidos em "module.exports.methodName = methodName;"
                <br>const varName = require('./fileName'); --- não precisa colocar a extensão .js
                <br>para usar essas funções importadas, é só inserir o comando "fileName.methodName(value)"
                <br>é necessário tudo que for exportado ter o comando de exportar, se não retorna undefined
                <br>além de exportar um por vez, é possível fazer um objeto referenciando e depois exportar esse objeto
                <br>const fileName = { methodName: methodName; methodName2: methodName2} // method.exports.fileName
                <br>também é possível escrever a função já sendo exportada, sendo assim
                <br>module.exports.add = (x, y) =&gt; x + y;
                <br>no lugar de "module.exports.methodName", é possível usar a forma abreviada "exports.methodName"
                <br>
                <br>
                <br>é possível ter vários arquivos .js com informações diferentes sendo exportadas em uma pasta, e importar essa pasta, inicialmente funciona da seguinte maneira: contanto que dentro dessa pasta tenha todos os arquivos exportando as informações que precisam exportar, e deve haver dentro da pasta um arquivo com o nome de "index.js", importando todas as informações dos outros arquivos também dentro da pasta, exportando todas elas dentro de uma array, que terá vários objetos por exemplo
                <br>
                <br>
                <br>NPM (Node Package Manager)
                <br>NPM is really two things:
                <br>1.a library of thousands of packages published by other developers that we can use for free!
                <br>2.a command line tool to easily install and manage thos packages in our Node projects
                <br>comando no terminal é "npm install packageName", "npm i packageName" é uma abreviação
                <br>é possível instalar vários pacotes de uma vez separando os nomes"npm i package1 package2 etc"
                <br>é recomendado criar uma pasta e instalar dentro dessa pasta, pois pode baixar vários arquivos
                <br>normalmente é criado "node_modules" contendo tudo necessário do pacote, e "package-lock.json" que é um registro do conteúdo do diretório
                <br>se o arquivo em JavaScript estiver na mesma pasta que o node_modules, para adicionar o pacote é só utilizar o comando "const packagename = require('packageName')"
                <br>existem pacotes que dependem de outros para funcionar, se tiver todas elas serão baixadas junto ao node_modules
                <br>é possível instalar vários pacotes na mesma pasta, usando o comando para instalar cada pacote de forma separada, o próprio Node.js fará a adição dos pacotes
                <br>dentro da pasta junto ao node_modules, um arquivo em .js pode solicitar os pacotes adicionados usado "const packageName = require ('packageName')"
                <br>para instalar um pacote globalmente, basta utilizar a extensão de comando -g "npm install -g packageName", instala no diretório usr/local/lib/node_modules, e fica disponível em qualquer arquivo, se der algum erro de permissões, existe uma linha de comandos que talvez possa resolver, "sudo chown -R $USER /usr/local/lib/node_modules"
                <br>para pacotes instalados de maneira global, não é necessário usar o require, se der algum erro é só usar o comando "npm link packageName"
                <br>
                <br>package.json é um arquivo especial com o nome especial que será colocado dentro de cada aplicativo de notas que for criado, não é obrigatório, mas é recomendado, contém a metadata/informações sobre o projeto, pacote ou aplicativo, indica comandos, descrição, dependencias, autor, versão, etc.
                <br>normalmente esse arquivo em JSON é criado usando o terminal, usando o comando "npm init", em seguida é só inserir os dados que forem solicidatos, e no final o arquivo em .json será criado no mesmo diretório
                <br>é importante criar esse arquivo, para quando instalar pacotes utilizando o terminal, não apresentar o erro de não achar o package.json, e também para ficar evidente todos os pacotes utilizados
                <br>nas versões dos pacotes, o símbolo "^" significa maior que, exemplo versão "packageName": "^1.5.0"
                <br>o package.json é importante para arquivos de outros usuários, pois possibilita instalar todos os pacotes usados de maneira mais fácil
                <br>dentro de um projeto com o package.json, basta utilizar no terminal o comando "npm install" isolado dentro do diretório correto, e assim ele instalará todos os pacotes listados no arquivo .json com suas versões corretas
                <br>é bastante útil já que na maioria das vezes o compartilhamento do arquivo node_modules se torna bem mais pesado
                <br>"npm init -y" cria o package.json preenchendo todos os campos automaticamente
            </p>
            <h3>Creating Servers With Express</h3>
            <p>
                Express
                <br>express é um pacote do Node.js
                <br>our first framework
                <br>express is a "fast, unopinated, minimalist web framework for Node.js" it hel us build web apps!
                <br>it's just an NPM package which comes with a bunch of methods and optional plugins that we can use to
                build web applications API's
                <br>Express help us... start up a server to listen for requests, parse incoming requests, match thos
                requests to particular routes, craft our http response and associated content
                <br>library vs framework
                <br>library: when you use a library, you are in charge! you control the flow of the application code,
                and you decide when to use the library
                <br>framework: with frameworks, that control is inverted, the framework is in charge, and you are merely
                a participant! the framework tells you where to plug in the code
                <br>
                <br>our very first express app
                <br>
                <br>const express = require('express'); // importa express
                <br>const app = express() // define app como a função express
                <br>app.use(() => { console.log('We got a new request!') }) // executado sempre que há uma solicitação
                <br>app.listen(3000, () => { console.log('Listening on port 3000') }) // "server running" on port 3000
                <br>
                <br>no browser, se colocar o comando "localhost:port", aparecerá as informações respondidas do server
                <br>para reiniciar o localhost, no bash do linux é usado command+c, no git bash é só reabrir o programa
                <br>as portas 3000 e 8080 são comuns para testes, é importante observar qual está utilizando
                <br>é possível rodar mais de um servidor com portas diferentes ao mesmo tempo
                <br>app.use(request, response)
                <br>request tem todas as informações da solicitação, incluindo o url solicitado
                <br>request tem métodos para enviar informações ao usuário que está fazendo as solicitações
                <br>é possível usar o postman com localhost, para testar as funcionalidades
                <br>pelo postman é possível ver o tipo de conteúdo que é retornado na resposta (headers)
                <br>res.send('Hello, we got your request! This is a response!') --- conteúdo text/html
                <br>res.send({color: 'red'}) --- conteúdo application/json
                <br>res.send('&lt;h1&gt;Title H1&lt;/h1&gt;') --- conteúdo text/html (o browser renderiza como html)
                <br>
                <br>express routing basics
                <br>routing não é específico do express, em qualquer servidor que desenvolvemos, routing é um termo
                comum, que se refere as solicitações e um caminho correspondente para algum código
                <br>app.get(path, (req, res) =&gt; {func}) --- tem um caminho, e uma callback function
                <br>é necessário tirar o res.send, pois sempre que o res.send é chamado, é o fim da solicitação, não é
                possível ter um http que obtem mais de uma resposta
                <br>app.get, app.post, app.put, app.delete, etc
                <br>app.method('*', (req, res) =&gt; { res.send }) --- para qualquer outro caminho do método a resposta
                será definida pela indicação de '*', é importante ser a última opção do código, pois se vir antes, todo
                o código abaixo será ignorado
                <br>
                <br>express path parameters
                <br>da maneira acima, é preciso fazer a solicitação exatamente como foi descrita, utilizando o método e
                o caminho exato, mas existe uma maneira de padronizar isso, para não ser necessário criar uma rota
                específica para centenas ou milhares de consultas, sendo mais ou menos "baseUrl/term/everything"
                <br>app.method('/term/:userSearch', (req, res) =&gt; { res.send('this is userSearch!') })
                <br>(":") na variável significa que pode ser qualquer coisa no lugar da variável, inserida pelo usuário
                <br>é possível saber o que foi inserido na variável (no caso "userSearch") pelo objeto req(request)
                <br>req.params = { userSearch: 'Something' } --- um objeto com todas as propriedades inseridas
                <br>
                <br>app.get('r/:userSearch', (req, res) =&gt; {
                <br> const { userSearch } = req.params;
                <br> console.log(`User search request for ${userSearch}! (GET)`)
                <br> res.send(`&lt;h1&gt;This is the results of the user search for ${userSearch}!&lt;/h1&gt;`)
                <br>})
                <br>é possível ter mais de uma variável que é definida pelo usuário, ou gerada de forma automática
                <br>'r/:userID/:userSearch'
                <br>
                <br>
                <br>working with query strings
                <br>query string é um par key-value em que o usuário digita um termo e esse termo é a pesquisa da página
                "?queryTerm = userSearch"
                <br>definir uma rota e usar query strings são duas maneiras "parecidas", mas com funcionalidades
                distintas
                <br>o req(request) tem um parâmetro chamado query, que retorna um objeto com todos os parâmetros
                inseridos na url "req.query"
                <br>
                <br>app.get('/search', (req, res) =&gt; {
                <br> console.log('Searching for:', req.query);
                <br> const { q } = req.query;
                <br> if (!q) {
                <br> res.send('&lt;h1&gt;Nothing found if nothing searched!&lt;/h1&gt;')
                <br> } else {
                <br> console.log(`Search request for ${q} (GET)`)
                <br> res.send(`&lt;h1&gt;Search results for ${q}!&lt;/h1&gt;`)
                <br> }
                <br>})
                <br>
                <br>é possível ter mais de um termo na url, separados por ("&"):
                <br>http://localhost:3000/search?q=querySearch&year=2022&mounth=january&day=21
                <br>
                <br>
                <br>auto-restart with nodemon
                <br>normalmente, para reiniciar o servidor pelo git bash para testar novamente o site assim que alguma
                coisa for alterada, até o momento é necessário fechar o git bash, abrí-lo denovo, usar o comando "cd
                /../../.." até chegar na pasta do arquivo, e em seguida executá-lo utilizando "node fileName.js"
                <br>porém existe uma boa maneira de basicamente reiniciar o servidor automaticamente sempre que mudarmos
                o código base
                <br>é necessário instalar o pacote nodemon, e para executar o arquivo .js, o comando ao invés de ser
                "node fileName.js", se torna "nodemon fileName.js", e sempre que ele detectar alguma mudança no código,
                automaticamente reinicia o servidor, economizando tempo
                <br>é uma ferramenta útil para ser instalada globalmente, já que é útil para qualquer aplicação que for
                ser desenvolvida
                <br>para qualquer modificação feita nos arquivos com as extensões ".js",".mjs",".json" dentro do
                diretório, ele reiniciará e dará um feedback no terminal
            </p>
            <h3>Creating Dynamic HTML With Templating</h3>
            <p>
                Criando templates para não precisar fazer uma página para cada :userInput dentro de de query em URLs
                <br>páginas para subreddits por exemplo, cria o template pra uma que serve pra qualquer tópico criado
                <br>templating allows us to define a preset "pattern" for a webpage, that we can dynamically modify
                with, for example, we could define a single "search" template that displays all the results for a given
                search term.We don't know what the term is or how many results where are ahead of time. The webpage is
                created on the fly
                <br>EJS, Handlebars, Jade, Interpolation Pug, Nunjucks - Templating languages
                <br>EJS é o mais recomendado porque é mais fácil, já que não apresenta uma sintaxe própria, não
                necessitando de aprender as funções e métodos de uma nova linguagem
                <br>EJS (Embedded JavaScript templating), muito popular e comumente utilizado, existe vários projetos no
                GitHub por exemplo, e a sintaxe é a mesma sintaxe do JavaScript
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>configuring express for ejs
                <br>app.set(aceita 2 argumentos, a chave e o valor da propriedade (key-value pair))
                <br>app.set('view engine', 'ejs') // usar o EJS como ferramenta para a view engine
                <br>por padrão, quando criamos um novo aplicativo express, e estamos usando alguma view engine, o
                express irá assumir que as visualizações são modelos existentes em uma pasta chamada views (é possível
                alterar)
                <br>
                <br>
                <br>//dentro do terminal:
                <br>npm init -y
                <br>npm i express
                <br>npm i ejs
                <br>mkdir views
                <br>touch index.js // comandos pelo terminal
                <br>touch views/random.ejs
                <br>touch views/home.ejs // é importante terminar com .ejs ao inves de .js
                <br>
                <br>
                <br>//dentro do arquivo index.js:
                <br>const express = require('express'); //não é necessário solicitar o ejs, o express faz isso
                automaticamente
                <br>const app = express();
                <br>
                <br>app.set('view engine', 'ejs');
                <br>
                <br>app.get('/',(req,res) =&gt; {
                <br> res.render('home') // não é necessário a extensão .ejs, pois já foi definida na view engine, também
                não é necessário colocar o dirétório views/, pois o diretório padrão do res.render é a pasta views
                <br>})
                <br>
                <br>app.get('/rand', (req, res) =&gt; {
                <br> const num = Math.floor(Math.random() * 10) + 1;
                <br> res.render('random', {rand: num}) // o que estiver dentro de rand será disponível no template
                <br> // se for passado dentro do objeto somente { num }, é válido, pois é o mesmo que { num: num }
                <br>})
                <br>
                <br>app.get('/r/:subreddit',(req, res) =&gt; {
                <br> const { subreddit } = req.params;
                <br> res.render('subreddit', { subreddit });
                <br>})
                <br>
                <br>app.listen(3000, () =&gt; {
                <br> console.log ('listening on port 3000!')
                <br>})
                <br>
                <br>
                <br>//dentro do arquivo home.js dentro do diretório views:
                <br>escrita em HTML padrão, e apenas uma extensão, com recursos adicionais
                <br>! + TAB
                <br>
                <br>head title "homepage"
                <br>body
                <br>&lt;h1&gt;The Home Page&lt;/h1&gt;
                <br>&lt;p&gt;Lorem *10&lt;/p&gt;
                <br>&lt;p&gt;Lorem *10&lt;/p&gt;
                <br>
                <br>
                <br>//dentro do arquivo random.ejs dentro do diretório views:
                <br>! + TAB
                <br>head title "random"
                <br>body
                <br>&lt;h1&gt;Your random number is: &lt;%= rand %&gt;&lt;/h1&gt;
                <br>// rand precisa ser definido ou usando a lógica dentro de "&lt;%= %&gt;", ou sendo criado no arquivo
                index.js e sendo definido em um objeto, como é o caso
                <br>
                <br>
                <br>//dentro do arquivo subreddit.ejs dentro do diretório views:
                <br>! + TAB
                <br>head title &lt;%= subredddit %&gt;
                <br>body
                <br>&lt;h1&gt; Browsing the&lt;%= subredddit %&gt; subreddit &lt;/h1&gt;
                <br>
                <br>
                <br>para que a pasta views contendo os arquivos .ejs funcione corretamente, na hora de iniciar o
                servidor é necessário estar no diretório com a pasta views, se não apresentará um erro por não encontrar
                a falha
                <br>para isso é necessário editar o arquivo index.js com as informações:
                <br>
                <br>const path = requires('path')
                <br>app.set('views', path.join(__dirname, '/views'))
                <br>
                <br>a função path.join refere-se ao diretório, e __dirname é o diretório complexo de onde foi executado
                o arquivo .js, e adiciona em seguida /views
                <br>
                <br>
                <br>interpolation system
                <br>&lt;%= JavaScript template literal %&gt;
                <br>tudo dentro de "&lt;%= %&gt;" é tratado como um template literal de java script (``)
                <br>ex:
                <br>&lt;%= subreddit %&gt;
                <br>
                <br>
                <br>
                <br>
                <br>conditionals in EJS
                <br>adicionar lógica de JavaScript sem a necessidade de renderizar alguma coisa
                <br>&lt;% JavaScript logic %&gt; é parecido com interpolação, porém sem o "=" depois de &lt;
                <br>é necessário colocar "&lt;% %&gt;" no começo e no final de todas as linhas de lógica em JavaScript
                <br>ex:
                <br>&lt;% if(num % 2 === 0) {%&gt;
                <br>&lt;h2&gt; That is an even number! &lt;/h2&gt;
                <br>&lt;% } else {%&gt;
                <br>&lt;h2&gt; That is an odd number! &lt;/h2&gt;
                <br>&lt;% } %&gt;
                <br>&lt;h3&gt; &lt;%= num%2===0 ? 'EVEN' : 'ODD' %&gt; &lt;/h3&gt;
                <br>// é possível avaliar se o número é ímpar(odd) ou par(even) no index.js, várias maneiras
                <br>// para fazer esse tipo de lógica, é mais fácil escrever o código em JavaScript primeiro, depois
                adicionar as condições em HTML
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>loops in ejs
                <br>mesma sintaxe de conditionals, dentro de "&lt;% %&gt;""
                <br>útil para criar páginas de posts por exemplo, onde o conteúdo tem um padrão para cada item
                <br>&lt;% for(let post of posts) { %&gt;
                <br> &lt;h4&gt; &lt;%= post %&gt; &lt;/h4&gt;
                <br> &lt;% if(post.img) { %&gt;
                <br> &lt;img src="&lt;% post.img %&gt;" alt=""&gt;
                <br> &lt;% } %&gt;
                <br>&lt;% } %&gt;
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>serving static assets in express
                <br>basicamente é incluir na reposta .css e .js no lado do cliente
                <br>app.use(express.static('public')) --- express.static(root, [options])
                <br>middleware = algo que ocorre entre as solicitações que chegam e as respostas que são enviadas
                <br>app.use(express.static('public')); --- usar o diretório "public", e dentro dele contém os arquivos
                <br>para usar o link no arquivo em HTML(EJS) dentro de views, não é necessário referenciar que está
                dentro da pasta public, pois ela já está acessível, apenas é necessário "fileName.extension"
                <br>é possível também criar diretório dentro de public para organizar, como css, js, imgs, etc, nesse
                caso se torna necessário referenciar a pasta com "/css/app.css" por exemplo
                <br>também é recomendado usar um absolute path, para quando for iniciado pelo terminal, não ter a
                necessidade de ser no mesmo diretório em que ela está, adicionando:
                <br>app.use(express.static(path.join(__dirname, 'public'))); --- não é necessário usar require('path')
                mais de uma vez, uma vez serve para o arquivo inteiro
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>bootstrap + express
                <br>download compiled css and js in bootstrap
                <br>criar os diretórios "css" e "js" dentro do diretório "public"
                <br>//na pasta css; bootstrap.min.css // na pasta js; bootstrap.min.js
                <br>é importante também dentro de public/js ter o arquivo jquery, para evitar erros
                <br>para importar basta colocar na head do ejs o link bootstrap css, o script jquery e o script
                bootstrap, o JQUERY precisa ser carregado antes do BOOTSTRAP, nos scripts em head
                <br>copiar a navbar do site do bootstrap, customizá-la, e para adicionar em todas as páginas criadas sem
                precisar inserir no arquivo HTML(EJS) um por um, existe uma maneira mais fácil: partials.
                <br>
                <br>
                <br>ejs and partials
                <br>é uma maneira de incluir "subtemplates" dentro de templates, um recurso extremamente útil
                <br>economiza tempo para a inclusão de arquivos css e js generalizados, como bootstraps, não é
                necessário incluir bootstrap em cada arquivo único, é póssível utilzar os métodos de partials
                <br>para fazer isso, basta criar um diretório dentro de views, com o nome de partials
                <br>nesse partials, é possível recortar todo o head até o !doctype html, e modificá-lo, assim nos
                arquivos que serão escritos pelo HTML(EJS) utilizando esse mesmo head, já irão começar a escrita no
                body, porém antes do body irão chamar a função &lt;%- include('partials/head') %&gt; para incluir todo o
                texto do head.ejs criado em /views/partials
                <br>é necessário avaliar os erros, que podem acontecer por motivos simples como chamar variáveis que não
                existem em outras visualizações de páginas
                <br>a mesma coisa para a navbar, é recortada depois de customizada, em um arquivo que pode ser chamado
                navbar.ejs, contendo todos os botões, propriedades da navbar, e no início de body dos outros documentos
                em views, onde ficaria essa escrita da navbar, é chamada a função &lt;%- include('partials/navbar')
                %&gt;, economizando assim muito tempo caso for feita uma modificação futuramente, e reduzindo o código
                <br>é como se tudo dentro de &lt;%- &gt; estivesse escrito no arquivo HTML(EJS), interpretado como
                HTML(EJS)
            </p>
            <h3>Defining RESTful Routes</h3>
            <p>
                GET vs POST
                <br>GET: used to retrieve information, data is sent via query string, information is plainly visible in
                the URL, limited amount of data can be sent; search term, filters, sort by, query, etc
                <br>POST: used to post data to the server, used to write/create/update, data is sent via request body,
                not a query string, can send any sort of data(json); posting data, send to server, any type of data,
                <br>GET não tem acesso a enviar body, tudo é restrito ao URL, no body (disponível no POST), é possível
                enviar mais conteúdo, e não é um conteúdo visível através da URL
                <br>
                <br>
                <br>defining express post routes
                <br>app.get e app.post são definidas no arquivo com express (index.js), se for definido somente GET para
                um endereço 'localhost:3000/send' por exemplo, e tentar enviar um POST, irá receber um erro (visível
                através do POSTMAN)
                <br>por isso é necessário definir "app.get('/send', (req, res) () =&gt; {get func}))", e também
                "app.post('/send', (req, res) () =&gt; {post func}))"
                <br>
                <br>
                <br>parsing the request body
                <br>req.body (request.body) no index.js informa o body da request, porém é necessário informar que tipo
                de dado(código) ele vai enviar de volta, que por padrão é undefined, é preciso explicar explicitamente
                (json por ex)
                <br>app.use(express.urlencoded({ extended: true })) // for parsing application /x-www-form-urlencoded
                <br>basicamente usa essa função como middleware, que irá analisar o corpo da solicitação como dados
                codificados por url
                <br>irá retornar um objeto contendo o par key-value, e para usar esse objeto, é necessário assimilá-lo
                no index.js
                <br>const { nomeVar, nomeVar2 } = req.body;
                <br>res.send(`OK, HERE ARE YOUR ${nomeVar} of ${nomeVar2}`)
                <br>se tentar enviar pelo submit do form com ação post, irá funcionar, porém utilizando o body do
                postman escrevendo em JSON, irá retornar undefined para os dois valores, pois ele está analisando um
                tipo de valor diferente, para isso é necessário utilizar a função middleware de JSON:
                <br>app.use(express.json())
                <br>é possível utilizar um ou mais middlewares ao mesmo tempo
                <br>
                <br>intro to rest (REpresentational State Transfer)
                <br>rest is an "architectural style for distributed hypermedia systems". Yikes. it's basically a set of
                guidelines for how a client + server should communicate and perform CRUD operations on a given resource
                <br>the main ideia of rest isn treating data on the server-side as resources than can be CRUDed, the
                most common way of approaching rest is in formating the urls and http verbs in your applications
                <br>CRUD (Create Read Update Delete)
                <br>resource é a "extensão do url"
                <br>verbo PATCH é usado para indicar que algo está sendo atualizado na página através de uma solicitação
                <br>verbo DELETE é usado para apagar algo an página através de uma solicitação
                <br>verbo PUT também é usado para atualização de informações através de solicitações
                <br>REST routes não precisam ser especificadas dessa maneira, "é um caminho mais amplo"
                <br>
                <br>
                <br>RESTful comments overview
                <br>é possível ter vários verbos HTTP associados ao mesmo endereço de url, cada um fazendo uma coisa
                diferente, utilizando um identificador no plural, como "comments", possuindo GET,POST etc e um id
                específico para cada coment, "comments/:id", uma maneira melhor de fazer urls, com PUT PATCH etc
                <br>
                <br>exemplo utilizando comments como recurso:
                <br>NAME | PATH | VERB | PURPOSE
                <br>Index | /comments | GET | Display all comments
                <br>New | /comments/new | GET | Form to create new comment
                <br>Create | /comments | POST | Creates new comment on server
                <br>Show | /comments/:id | GET | Details for one specific comment
                <br>Edit | /comments/:id/edit | GET | Form to edit specific comment
                <br>Update | /comments/:id | PATCH | Updates specific comment on server
                <br>Destroy | /comments/:id | DELETE | Deletes specific item on server
                <br>
                <br>
                <br>express redirects
                <br>res.redirect('/url') redireciona a página rapidamente com o status code 302(padrão), e a resposta
                para o usuário será redirecionar, é um post e rapidamente em seguida um get
                <br>
                <br>
                <br>restful comments show
                <br>criação de um id único para cada item da lista
                <br>abrir um "post" e dentro do identificador exibindo este post, os comentários do post
                <br>
                <br>
                <br>the uuid package (universal unique id)
                <br>npm i uuid
                <br>para os detalhes de comentários no banco de dados irá funcionar normalmente, porém se o id não
                existir, apresentará um erro
                <br>não é uma boa prática escrever os ids por conta prórpia
                <br>UUIDV4, pacote que cria um id único para cada item, muito usado
                <br>
                <br>
                <br>restful comments update
                <br>PUT request --- atualiza completamente as informações de alguma coisa (modificação total)
                <br>PATCH request --- atualiza um pedaço de informação de alguma coisa (modificação parcial)
                <br>app.patch // app.METHOD(patch)
                <br>
                <br>
                <br>method-override package
                <br>npm i method-override
                <br>por padrão, o browser só consegue enviar os métodos GET e POST, mas o pacote method-override, deixa
                possível enviar os outros, PUT, DELETE, etc
                <br>const methodOverride = require('method-override') // app.use(methodOverride('_method'))
                <br>e a ação do form será
                <br>action="/resource?_method=PATCH", será tratado como o método patch
                <br>é necessário colocar o método do formulário como post, mas apesar de ser um post, o método será
                sobrescrito pelo que for inserido na action
                <br>
                <br>
                <br>restful comment delete
                <br>?_method=DELETE using method-override
                <br>utilizando filter, para recriar a array com todos os itens, menos o deletado
                <br>usa o id para saber qual id é deletado
                <br>full CRUD mini app is done :)
            </p>
            <h3>MongoDB</h3>
            <p>
                our first database: MongoDB
                <br>introduction to database
                <br>why use a data base? (instead of just saving to a file)
                <br>databases can handle large amounts of data efficiently and store it compactly, they provide tools
                for easy inserion querying and updating of data, they generally offer security features and control over
                access to data, they (generally) scale well
                <br>what is mongo? abording to mongo's homepage, it is "the most popular database for modern
                applications". It is commonly used in combination with Node. Mongo is a document database, which we can
                use to store and retrieve complex data from
                <br>
                <br>
                <br>SQL vs NoSQL databases
                <br>SQL (Structured Query Language) - SQL databases are relational databases. we pre-define a schema of
                tables before we insert anything // MySQL, Postgres, SQLite, Oracle, Microsoft SQL Server, etc
                <br>NoSQL (Non Structured Query Language) - NoSQL databases do not use SQL there are many types of
                no-sql databases, including document,key-value and graph stores // MongoDB, CouchDB, Neo4j, Cassandra,
                Redis, etc
                <br>
                <br>
                <br>why use mongo?
                <br>mongo is very commonly used with Node and Express (MEAN & MERN stacks), it's easy to get started
                with (though it can be tricky truly master), it plays particulary well with JavaScript, its popularity
                also means there is a strong community of developers using mongo
                <br>installation mongo guide: https://www.youtube.com/watch?v=MCpbfYvvoPY
                <br>C:\mongodb\bin // C:\data\db // excetuar: Windows PowerShell ou Git Bash (mongod + mongo)
                <br>depois de executado, é um shell em JavaScript
                <br>
                <br>
                <br>comandos no mongo
                <br>show dbs --- mostra os bancos de dados criados
                <br>use dataBaseName --- cria um novo banco de dados
                <br>o banco de dados só é criado se alguma coisa de fato for adicionada a ele
                <br>db --- mostra o banco de dados atual
                <br>
                <br>
                <br>BSON (data stored in mongo databases have BSON format, more compact than JSON)
                <br>BSON (Binary JSON) - more compact version of JSON, inclui diferentes tipos de dados, não é igual ao
                JSON,
                <br>
                <br>
                <br>inserting with mongo
                <br>CRUD documentation for MongoDB - https://docs.mongodb.com/manual/crud/
                <br>uma collection é um grupo de dados em um banco de dados
                <br>se tentar inserir algum dado em uma coleção inexistente, ela será criada automaticamente
                <br>db.collection.insert() --- inserir dados
                <br>show collections --- mostra as coleções já criadas
                <br>db.collection.find() --- mostra os objetos da coleção (é necessário estar no banco de dados certo
                para usar esse comando)
                <br>
                <br>db.dogs.insertOne({name: "Charlie", age: 3, breed: "corgi", catFriendly: true})
                <br>inserção de um objeto contendo as propriedades descritas na coleção "dogs"
                <br>cria um _id, uma chave primária que é única para cada elemento
                <br>
                <br>db.dogs.insert([{name: "Wyatt", breed: "Golden", age : 14, catFriendly: false}, {name: "Tonya",
                breed: "Chihuahua", age: 17, catFriendly: false}])
                <br>db.cats.insert({name: "Blue Steele", age: 6, dogFriendly: false, breed: "Scottish fold"})
                <br>db.dogs.find({breed: "Corgi"}) --- encontra todos os elementos com a mesma propriedade definida no
                objeto dentro dos parênteses
                <br>db.dogs.findOne({catFriendly: true}) --- recebe somente um elemento com a propriedade definida nos
                parâmetros de pesquisa da função (é possível inserir vários)
                <br>
                <br>
                <br>updating with mongo
                <br>updateOne irá atualizar os dados do primeiro resultado
                <br>updateMany irá atualizar os dados de todos os resultados
                <br>o primeiro objeto é um selecionador, e o segundo é o método/valor a ser alterado
                <br>db.dogs.updateOne({name: "Charlie"}, {$set: {age: 4}}) -- $set atualiza: {$set: {key: value}}
                <br>se usar o set para inserir um valor que ainda não existe, será criado esse novo valor e atribuido ao
                elemento será selecionado
                <br>$currentDate: {lastModified: true} --- adiciona a data atual como última modificação do arquivo
                <br>é possível inserir múltiplos operadores simultaneamente, usando vírgula após os operadores
                <br>db.collection.updateOne({key: value}, {$set: {key: value}, $currentDate: {lastChanged: true}})
                <br>replace --- usado para alterar completamente o conteúdo de um elemento, só mantendo o ID do mongo
                <br>
                <br>
                <br>deleting with mongo
                <br>deleteOne --- deleta um elemento com os critérios de busca correspondido
                <br>deleteMany --- deleta todos os elementos com os critérios de busca correspondido
                <br>db.cats.deleteOne({name: 'Blue Steele'}) --- deleta o objeto com a propriedade name escolhida
                <br>é possível inserir mais de um critério de busca para a escolha dos elementos a serem excluídos
                <br>db.dogs.deleteMany({catFriendly: false}, {age: 2}) --- deleta todos os elementos com a propriedade
                <br>
                <br>
                <br>additional mongo operators
                <br>é possível ter uma propriedade com o valor de um objeto de outras propriedades
                <br>[{ personality: { catFriendly: true, childFriendly: true }}]
                <br>para encontrar os objetos com a propriedade catFriendly, usa-se o método com um ponto
                <br>db.dogs.find({'personality.catFriendly': true})
                <br>
                <br>comparers, $ matches all values of -
                <br>$eq - equal
                <br>$gt - greater than
                <br>$gte - greather than or equal
                <br>$in - any of the values specified in an array
                <br>$lt - less than
                <br>$lte - less than or equal
                <br>$ne - not equal
                <br>%nin - none of the values specified in an array
                <br>
                <br>ex: db.dogs.find({age: {$gt: 8}})
                <br>ex: db.dogs.find({breed: {$in: ['Mutt', 'Corgi']}})
                <br>
                <br>logical operators
                <br>$and - logical and
                <br>$not - logical not
                <br>$nor - returns all documents that fail to match both clauses
                <br>$or - logical or
                <br>
                <br>ex: db.dogs.find($and: [{age: {$gt: 5}, {$lt:10}}])
                <br>
                <br>existem outros tipos de operadores, disponíveis nas páginas de documentação do MongoDB
            </p>
            <h3>Connecting to Mongo with Mongoose</h3>
            <p>
                Mongoose
                <br>ODM (Object Data Mapper - Object Document Mapper)
                <br>ODMs like Mongoose map documents coming from a database into usable JavaScript objects
                <br>Mongoose provides ways for us to model our application data and define a schema. it offers easy ways
                to validate data and build complex queries from the comfort of JS
                <br>
                <br>use the quick start guide on mongoose website (have a new syntax using async func)
                <br>old syntax to use mongoose, but functional, aparentemende o servidor mongodb precisa estar rodando
                (mongod)
                <br>
                <br>const mongoose = require('mongoose');
                <br>mongoose.connect('mongodb://localhost:27017/movieApp', { useNewUrlParser: true, useUnifiedTopology:
                true })
                <br> .then(() =&gt; {
                <br> console.log("CONNECTION OPEN!!!")
                <br> })
                <br> .catch(err =&gt; {
                <br> console.log("OH NO ERROR!!!!")
                <br> console.log(err)
                <br>})
                <br>
                <br>models
                <br>models são apenas classes, como as classes em JavScript, que fazemos com a ajuda do mongoose, e
                representam informações em um banco de dados MongoDB, informações de uma coleção
                <br>
                <br>
                <br>schema (esquemático, como um projeto, um "plano")
                <br>é um mapeamento de diferentes chaves de coloeção do mongo para diferente tipos em JavaScript
                <br>para definir um schema, é necessário usar a sintaxe:
                <br>const movieSchema = new mongoose.Schema ({
                <br> title: String,
                <br> year: Number,
                <br> score: Number,
                <br> rating: String
                <br>})
                <br>
                <br>e para criar um modelo utilizando esse schema,
                <br>const Movie = mongoose.model('Movie', movieSchema); --- model('Name', schemaCreated)
                <br>apesar de criar um modelo utilizando a primeira letra maiúscula, o próprio mongoose criará uma
                coleção com esse nome no plural, e todas as letras minúsculas
                <br>
                <br>depois do schema e do modelo criados, é possível criar novas instâncias e salvá-las no banco de
                dados
                <br>
                <br>const amadeus = new Movie({ title: 'Amadeus', year: 1986, score: 9.2, rating: 'R'});
                <br>é possível ter acesso a esse item utilizando o banco de dados
                <br>
                <br>pelo terminal para executar o index.js:
                <br>node
                <br>.load index.js
                <br>
                <br>agora amadeus é um item visualizável, e com um "_id" criado automaticamente
                <br>apesar do objeto ser visualizável ele ainda não foi criado de fato no banco de dados
                <br>para criá-lo no banco de dados é necessário utilizar o comando
                <br>amadeus.save()
                <br>retorna uma promessa
                <br>e depois disso é possível visualizá-lo pelo banco de dados (mongo) usando o comando:
                <br>db.movies.find()
                <br>é possível atualizar os dados utilizando o comando no terminal do .load utilizando
                <br>amadeus.score = 9.5 // e em seguida // amadeus.save()
                <br>o valor é alterado pelo terminal, e depois salvo atualizado no banco de dados criado
                <br>
                <br>
                <br>insert many
                <br>Movie.inserMany([{ movie1 specs }, {movie2 specs }, { etc }])
                <br>para inserir apenas um objeto, é necessário utilizar o Movie.save
                <br>utiliznado o insertMany, todos os objetos inseridos automaticamente são salvos no banco de dados
                <br>
                <br>
                <br>finding with mongoose
                <br>os operadores $gt por exemplo, são os mesmos de mongodb
                <br>mongoose queries, thenables objects, similares a promises
                <br>Movie.find({year: {$gt: 1980}}).then(data =&gt; console.log(data))
                <br>Movie.find({ title: amadeus }).then(data =&gt; console.log(data))
                <br>retorna um querie object, não retorna a data imediatamente
                <br>Movie.findOne({}) --- retorna somente o primeiro filme que corresponde as buscas
                <br>await Movies.findOne().exec(); --- método exec utiliza async func e
                <br>Movie.findById('_id').then(m =&gt; console.log(m))
                <br>
                <br>
                <br>updating with mongoose
                <br>Movie.updateOne({ title: 'Amadeus'}, { year: 1984 }).then(res =&gt; console.log(res));
                <br>atualiza o ano para 1984 do primeiro resultado com o nome Amadeus
                <br>retorna n, nModified e ok --- n: número de resultados, nModified: atualizados, ok: 1
                <br>Movie.findOneAndUpdate({ title: 'Amadeus'}, { year: 1984 }).then(m =&gt; console.log(m)); ---
                assim que atualiza retorna o objeto na versão antes de atualizar
                <br>Movie.findOneAndUpdate({ title: 'Amadeus'}, { year: 1984 }, { new: true }).then(m =&gt;
                console.log(m));
                <br>para retornar o objeto na versão atualizada, é necessário utilizar o terceiro parâmetro, de opções
                <br>
                <br>
                <br>deleting with mongoose
                <br>Movie.remove({title: 'Alien'}).then(msg =&gt; console.log(msg))
                <br>Movie.deleteMany({year: {$gte: 1999}}).then(msg =&gt; console.log(msg))
                <br>retornam somente o número de itens deletados
                <br>Movie.findOneAndDelete({title: 'Alien'}).then(msg =&gt; console.log(msg))
                <br>retorna o objeto deletado
                <br>
                <br>
                <br>mongoose schema validations
                <br>uma chave pode ter um objeto de valores, type: jsType, required: true/false
                <br>valores adicionais usados para criar um novo objeto utilizando o modelo serão ignorados
                <br>all schema types:
                <br> required - default - select - validate - get - set - alias - immutable - transform
                <br> required: torna necessário a inserção do campo
                <br> default: valor padrão caso não seja inserido nenhum valor
                <br>para tipos de entradas diferentes é possível usar alguns métodos
                <br> String: lowercase - uppercase - trim - match - enum - minlenght - maxlength
                <br> Number: min - max - enum
                <br> Date: min - max
                <br>enum: precisa ser um valor dentro dos valores fornecidos, exemplo tamanho:
                <br>{ type: String, enum: ['S', 'M', 'L'] }
                <br>precisa ser S, M ou L, qualquer valor além disso será invalido
                <br>
                <br>validating mongoose updates
                <br>as restrições são aplicadas automaticamente quando os elementos estão sendo criados
                <br>as restrições não são aplicadas automaticamente quando os elementos vão ser atualizados
                <br>é possível utilizar as restrições utilizando: { runValidators: true }
                <br>Product.findOneAndUpdate({ name: 'Mountain Bike'}, { price: -10 }, { runValidators: true
                }).then(data =&gt; {console.log(data)}.catch(err =&gt; {console.log(err)}))
                <br>
                <br>
                <br>mongoose validation errors (creating custom messages)
                <br>{ min: [10, 'Impossible without 10 units'], max: 15 }
                <br>
                <br>
                <br>model instance methods (creating custom methods)
                <br>uma maneira de adicionar uma funcionalidade ao modelo
                <br>não utilizar arrow functions, pode dar errors inesperados
                <br>productSchema.methods.nameOfMethod = function(cb) { func }
                <br>útil para criar validações, verificação de credenciais e coisas do tipo, para sites responsivos
                <br>
                <br>
                <br>adding model static methods
                <br>this dentro de model static reefere se a clase Product
                <br>productSchema.statics.fireSale = function () { return this.updateMany({}, {onSale: true, price: 0})
                }
                <br>Product.fireSale().then(res=&gt; console.log(res))
                <br>útil para fazer alguma atualização, adicionar métodos para todos os itens
                <br>maneira sofisticada de fazer uma atualização, colocada no topo do programa
                <br>
                <br>
                <br>mongoose virtuals
                <br>capacidade de adicionar propriedades a um schema que não existe no banco de dados, mas acessável
                através do mongoose
                <br>
                <br>const personSchema = new mongoose.Schema({
                <br> first: String,
                <br> last: String
                <br> })
                <br>personSchema.virtual('fullName').get(function () {
                <br> return `${this.first} ${this.last}`
                <br>})
                <br>const Person = mongoose.model('Person', personSchema);
                <br>const michael = new Person({ first: 'Michael', last: 'Jackson' })
                <br>michael.fullName // return 'Michael Jackson', mas não existe fullName no banco de dados
                <br>a coleção que será salva no mongodb terá o nome de people, gerada pela pluralização
                <br>
                <br>
                <br>defining mongoose middleware
                <br>mongoose tem a possibilidade de executar algum código antes e/ou depois de fazer algum método, como
                update remove, find etc
                <br>.pre (pré-middleware) .post (após-middleware)
                <br>
                <br>personSchema.pre('save', async function () {
                <br> this.first = this.first.toUpperCase();
                <br> this.last = this.last.toUpperCase();
                <br> console.log('about to save')
                <br>})
                <br>personSchema.post('save', async function () {
                <br> console.log('successfully saved')
                <br>})
            </p>
            <h3>Putting all together: Mongoose with Express</h3>
            <p>
                express + mongoose basic setup
                <br>npm init -y
                <br>npm i express ejs mongoose
                <br>touch index.js
                <br>mkdir views
                <br>
                <br>utilizando o insertMany, se algum dos itens não for validado, nenhum dos itens será adicionado (por
                padrão)
                <br>segundo argumento de res.render deixa os elementos disponíveis na página ejs
                <br>const products = await Product.find({}) // res.render('products/index', { products })
            </p>
            <h3>Middleware: The Key To Express</h3>
            <p>
                intro to the express middleware
                <br>autentication, log in, logout, etc
                <br>request &gt; middleware &gt; response
                <br>express middleware are functions that run during the request/response lifecycle
                <br>middleware are just functions, each middleware has access to the request and response objects,
                middleware can end the HTTP request by sending back a response with methods like res.send(), OR
                middleware can be chained together one after another by calling next()
                <br>e possível ter mais de um middleware, um em sequência do outro
                <br>middlewares são funções que tem acesso aos objetos (req, res) and the next middleware function in
                application request-response-cycle
                <br>middlewares são capazes de executar código, fazer alterações no req,res, terminar o req-res-cycle,
                chamar "next" função middleware
                <br>
                <br>
                <br>using morgan - logger middleware
                <br>morgan docs (https://github.com/expressjs/morgan)
                <br>app.use() --- código que é executado em todas as solicitações
                <br>Morgan
                <br>app.use(morgan('tiny')) --- GET / 304 - - 1.000 ms // tiny / dev / common
                <br>tipo de solicitação, url, status http, tempo de resposta
                <br>
                <br>
                <br>defining our own middleware
                <br>app.use((req, res, next) =&gt; {
                <br> console.log('first middleware!')
                <br> return next();
                <br>})
                <br>é necessário usar o next, se não o app fica travado no app.use
                <br>return next é um meio de garantir que nada acontecerá depois de usar o next
                <br>se algo estiver escrito depois do next, e sem ter return, as coisas podem ocorrer de maneira
                inesperada
                <br>útil para verificar se um usuário está logado por exemplo, se estiver faz uma coisa, se não faz
                outra
                <br>app.use é executado antes de app.get
                <br>
                <br>
                <br>setting up a 404 route
                <br>é possível definir um app.use que só é executado em um caminho(url) específico, definido por:
                <br>app.use('/urlPath', (req, rest, next) =&gt; {
                <br> func
                <br> return next();
                <br>})
                <br>esse middleware só será executado quando o url for = url/urlPath especificado no app.use
                <br>app.use((req, res) =&gt; {
                <br> res.status(404).res.send('Not Found!')
                <br>})
                <br>é importante ser a última coisa do documento, pois se nada já especificado funcionar,
                <br>res.status define o status como 404, e no lugar de res.send é normalmente usado um res.render, de
                uma página criada especificamente para caso não ache resultados
                <br>
                <br>
                <br>password middleware demo (NOT REAL AUTH)
                <br>app.use((req, res, next) =&gt; {
                <br> const { password } = req.query;
                <br> if (password === 'senha') {
                <br> return next();
                <br> }
                <br> res.send('Sorry, you need a password')
                <br>})
                <br>todos os urls agora precisam de utilizar ?password=senha no seu final, se não a resposta é outra
                <br>
                <br>
                <br>protecting specific routes
                <br>const verifyPassword = ((req, res, next) =&gt; {
                <br> const { password } = req.query;
                <br> if (password === 'senha') {
                <br> return next();
                <br> }
                <br> res.send('Sorry, you need a password')
                <br>})
                <br>agora não é usado para qualquer solicitação, apenas nas rotas que utilizarem a verifyPassword
                <br>
                <br>app.get('/secret', verifyPassword, (req, res) =&gt; {
                <br>res.send('THE SECRET IS: carta de suicído programada para a expedição no dia 06/09/2052')
                <br>})
                <br>rota do url/secret agora precisa da senha ?password=senha para ser acessado
            </p>
            <h3>Handling Errors In Express Apps</h3>
            <p>
                erros podem acontecer por várias maneiras, erro de sintaxe, algo estar faltando, algum marcador, etc
                <br>é importante todos esses erros serem corrigidos antes do produto final, o site ao público
                <br>data incompleta, problemas com mongo ou interações, problemas com apis, serviçõs externos, etc podem
                ser erros comuns
                <br>API inativa, formulário incompleto, mongoose precisar ser validado, são alguns dos erros que são
                corrigidos
                <br>o express gera respostas de erros padrão "the default error handler"
                <br>na documentação tem como o erro é definido, sua mensagem e etc
                <br>é possível criar as próprias mensagens de erros
                <br>throw new Error('error message')
                <br>
                <br>
                <br>custom error handlers, writing error handlers
                <br>erros hanrdlers middlewares, need 4 arguments
                <br>app.use((err, req, res, next) =&gt; {
                <br> console.log('Error!')
                <br>})
                <br>next(err) --- pula para o próximo error handler, usado no final de um error handler
                <br>
                <br>
                <br>our custom error class
                <br>antes de usar throw em algum erro, é possível definir seu status HTTP, em res.status(401)
                <br>criar um arquivo AppError.js
                <br>class AppError extends Error {
                <br> constructor(message, status) {
                <br> super();
                <br> this.message = message;
                <br> this.status = status;
                <br> }
                <br>}
                <br>module.exports = AppError;
                <br>
                <br>app.use((err, req, res, next) => {
                <br> const { status = 500, message = 'Something Went Wrong' } = err
                <br> res.status(status).send(message)
                <br>})
                <br>
                <br>
                <br>handling async errors
                <br>interações com bancos de dados são funções que não são realizadas na hora, precisando lidar com
                esses erros de maneira assíncrona
                <br>em uma rota, é possível ter o terceiro argumento (next), que será tratado como erro
                <br>app.get('/products/:id', async (req, res, next) =&gt; {
                <br> if (!product) {
                <br> next(new AppError('Product Not Found', 404))
                <br> }
                <br>}
                <br>erros em funções assíncronas de rotas precisam do terceiro argumento next, e dentro de next() throw
                erro
                <br>
                <br>
                <br>handling more async errors!
                <br>mongoose errors, validações de parâmetros para criar um item no banco de dados por exemplo
                <br>em funções de criar um item por exemplo, solicitação POST, utilizar o terceiro argumento next após o
                endereço url, e a função que de fato é a validada, fica em try, e catch(e) {next(e;)}, para caso ocorra
                algum erro
                <br>criação / atualização de valores que podem acontecer erros devido a validações (informações
                incompletas por exemplo)
                <br>app.put('/products/:id', async (req, res, next) =&gt; {
                <br> try {
                <br> const { id } = req.params;
                <br> const product = await Product.findByIdAndUpdate(id, req.body, { runValidators: true, new: true })
                <br> res.redirect(`/products/${product._id}`)
                <br> } catch (e) {
                <br> next(e);
                <br> }
                <br>})
                <br>
                <br>app.get('/products/:id', async (req, res, next) =&gt; {
                <br> try {
                <br> const { id } = req.params;
                <br> const product = await Product.findById(id)
                <br> if (!product) {
                <br> throw new AppError('Product Not Found', 404)
                <br> }
                <br> res.render('products/show', { product })
                <br> } catch (e) {
                <br> next(e)
                <br> }
                <br>})
                <br>os new AppError's que foram inseridos anteriormente, agora são substituidos por throw, pois há um
                catch para esses erros
                <br>
                <br>
                <br>defining an async utility
                <br>para não precisar utilizar try e catch em todas as funções assíncronas, existe outra maneira que é:
                <br>nomear a rota com "wrapAsync", "catchAsync", "handleExpressErrorAsync"
                <br>o mais comum é wrapAsync, a função é definida no topo do documento
                <br>function wrapAsync(fn) {
                <br> return function(req, res, next){
                <br> fn(req, res, next).catch(e =&gt; next(e))
                <br> }
                <br>}
                <br>e em cada rota que é uma função assíncrona agora tem um wrapAsync(), ex:
                <br>app.get('/products/:id', wrapAsync(async (req, res, next) =&gt; {
                <br> const { id } = req.params;
                <br> const product = await Product.findById(id)
                <br> if (!product) {
                <br> throw new AppError('Product Not Found', 404)
                <br> }
                <br> res.render('products/show', { product })
                <br>}))
                <br>é comum ter wrapAsync e outras funções criadas pelo desenvolvedor em um documento separado,
                utilities.js por exemplo, que tem o que é relevante exportado, e importado no index.js
                <br>
                <br>
                <br>differentiating mongoose errors
                <br>podem acontecer diversos tipos de erro, validações, autorizações, não encontrado, etc
                <br>por padrão a mensagem criada no final do documento será a mesma para todo os erros, mas é possível
                personalizar essas mensagens de erros
                <br>existem tipos/classes distindos de erros no mongoose, e toda propriedade de erro tem um nome
                <br>é possível visualizar o nome do erro no console a partir do middleware definido por:
                <br>app.use((err, req, res, next) =&gt; {
                <br> console.log(err.name);
                <br> next(err);
                <br>})
                <br>os mongoose erros tem nomes, por exemplo; ValidationError, CastError, etc
                <br>é possível criar mensagens customizadas para esses mongoose errors que possuem nomes
                <br>interceptação de um tipo de erro particular, ValidationError, exemplo:
                <br>// product model, name --- required: [true, 'name cannot be blank'] --- mensagem personalizada
                <br> const handleValidationError = err =&gt; {
                <br> console.dir(err) --- propriedades do erro no terminal
                <br> return new AppError(`Validation Failed...${err.message}`, 400); --- resposta ao usuário
                <br>}
                <br>app.use((err, req, res, next) =&gt; {
                <br> console.log(err.name); --- saber qual tipo de erro
                <br> if (err.name === 'ValidationError') err = handleValidationError(err) --- tratamento para este erro
                <br> next(err); -- próximo middleware de erro
                <br>})
            </p>
            <h3>Data Relationships With Mongo</h3>
            <p>
                SQL relationships overview
                <br>relações entre diferentes tabelas de dados
                <br>como uma comparação small(few), medium(many) e large(bajillions)
                <br>one to few
                <br>embed the data directly in the document
                <br>usado até agora, as informações estão visíveis no programa de modelo para armazená-lo no banco de
                dados
                <br>all data is storage in same file directly on the object
                <br>const userSchema = new mongoose.Schema({
                <br> first: String,
                <br> last: String,
                <br> addresses: [
                <br> {
                <br> // cada address terá um id único
                <br> // o mongo trata cada address como um Schema embutido
                <br> // é possível não criar esse id para cada endereço utilizando:
                <br> // _id: {id: false},
                <br> street: String,
                <br> city: String,
                <br> state: String,
                <br> country: String
                <br> }
                <br> ]
                <br>})
                <br>const User = mongoose.model('User', userSchema);
                <br>
                <br>one to many
                <br>one option is to store your data separately, but then store references to document ID's somewhere
                inside the parent:
                <br>{
                <br> farmName: 'Fully Belly Farms',
                <br> location: 'Guinda, CA',
                <br> produce: [
                <br> ObjectId('2819781267781'),
                <br> ObjectId('1828678675667'),
                <br> ObjectId('8187777231283'),
                <br> ]
                <br>}
                <br>para criar, no documento é utilizado para o type:
                <br>const { Schema } = mongoose;
                <br>products: [{ type: Schema.Types.ObjectId, ref: 'Product' }]
                <br>o ref(referência) é o modelo em que os itens já existentes estão abrangidos
                <br>dessa maneira, cada objeto já existente é adicionado ao outro, e no banco de dados ao invés de
                mostrar as informações, ele mostra o ID do objeto que está dentro do outro
                <br>
                <br>Mongoose populate
                <br>populate é para ao invés de mostrar o object id de elementos armazenados dentro de outros, mostrar
                todas as suas informações que foram inseridas de acordo com o modelo
                <br>é possível utilizar o populate para exibir somente o campo escolhido (mais o id junto a ele),
                inserindo um segundo argumento
                <br>const t = await Tweet.find({}).populate('user', 'username');
                <br>user é o modelo de referência, e username é a propriedade para ser "populada"
                <br>
                <br>one to bajillions
                <br>with thousans or more documents, it's more efficient to store a reference to the parent on the child
                document
                <br>{
                <br> tweetText:'lol I just crashed my car because I was tweeting',
                <br> tags? ['stupid', 'moron', 'yolo'],
                <br> user: ObjectId('2133243243')
                <br>}
                <br>when an user have a lots of tweets is an example of child and parent relationship, one user to many
                tweets
                <br>
                <br>
                <br>mongo schema design
                <br>mongo blog post on schema design:
                https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-3
                <br>o link é da página 3, porém as 3 páginas são muito úteis para a criação de um projeto utilizando
                mongoDB
                <br>é possível "duplicar" informações utilizando mongo, por ser um non-SQL db
                <br>essa documentação é bem importante, devido ao fato de que o mongo te dá liberdade para armazenar os
                dados da maneira que bem entender, sem regras fixas de ordem por exemplo, por isso é bom ter alguma base
                de caminho para fazer o banco de dados
            </p>
            <h3>Mongo Relationships With Express</h3>
            <p>
                integração de vários módulos interconectados
                <br>uma cópia aprimorada da página de products utilizando mongoose e express
                <br>
                <br>
                <br>deletion mongoose middleware
                <br>pode ser parecido com o middleware do express, mas não possui nenhuma relação
                <br>o pré middleware não tem acesso a data, já o post middleware sim, pois é executado depois da função
                <br>deletar uma farm, e consequentemente todos os products dessa farm serão deletados
                <br>é como um usuário do twitter apagar sua conta, seus tweets serão removidos do banco de dados
                <br>precisa ser definido antes de definir o modelo de Farm
                <br>
                <br>farmSchema.post('findOneAndDelete', async function (farm) {
                <br> if (farm.products.length) {
                <br> const res = await Product.deleteMany({ _id: { $in: farm.products } });
                <br> console.log(res);
                <br> }
                <br>})
            </p>
            <h3>Express Router & Cookies</h3>
            <p>
                express router intro
                <br>usado para separar as rotas em mais de um documento, ao invés de ter um documento massivo com todas
                as rodas e métodos get,post,etc
                <br>documentação do router no express --- http://expressjs.com/en/5x/api.html#router
                <br>criar uma pasta "routes" no diretório do arquivo index.js
                <br>dentro da pasta routes, o arquivo em .js do prefixo de endereço url, por exemplo shelters.js
                <br>dentro de shelters.js, não é necessário incluir /shelters/ no url, pois ele será um prefixo no
                index.js
                <br>dentro de shelters.js é necessário incluir express, e definir
                <br>const router = express.Router();
                <br>dessa maneira, ao invés de definir as rotas por app.get, será router.get
                <br>router.get('/', (req, res) => {
                <br> res.send('All Shelters')
                <br>})
                <br>e no final do arquivo, esse router deverá ser exportado:
                <br>module.exports = router;
                <br>no index.js, deverá ser importado, utilizando:
                <br>const shelterRoutes = require('./routes/shelters');
                <br>e para utilizar todas as rotas /shelter, é usado:
                <br>app.use('/shelters', shelterRoutes); --- onde /shelters, é o prefixo dos endereços url
                <br>
                <br>
                <br>express router & middleware
                <br>ao invés de definir um middleware utilizando app.use no index.js, se o middleware só for necessário
                dentro de um "padrão" de urls criados dentro do diretório routes, é possível definí-lo dentro do arquivo
                de router separado, utilizando:
                <br>router.use((req, res, next) =&gt; {
                <br> if (req.query.isAdmin) {
                <br> next();
                <br> }
                <br> res.send('Sorry, not an admin.')
                <br>})
                <br>
                <br>
                <br>introducting cookies
                <br>what are they?
                <br>cookies are little bits of information that are stored in a user's browser when browsing a
                particular website. Once a cookie is set, a user's browser will send the cookie on every subsequent
                request to the site. Cookies allow use to make HTTP stateful
                <br>normalmente cada solicitação é feita sem ter nenhuma ligação com outra, mas utilizando cookies é
                possível armazenar algumas informações no navegador de um determinado usuário, que em novas solicitações
                enviará esse cookies para o servidor, que responderá com coisas como por exemplo, modo escuro/modo claro
                de um aplicativo
                <br>documentação sobre web cookies na wikipedia --- https://en.wikipedia.org/wiki/HTTP_cookie#Uses
                <br>é possível visualizar os cookies utilizados pela página no chrome dev tool(f12)/application/cookies
                <br>
                <br>
                <br>sending cookies (with express)
                <br>res.cookie('keyName', 'value'); --- no value, %20 é um espaço (" ") codificado
                <br>documentação sobre web cookie no site do express --- http://expressjs.com/en/4x/api.html#res.cookie
                <br>é possível enviar vários cookies contendo esses vários tipos de informação em um mesmo url
                <br>
                <br>
                <br>cookie parser middleware
                <br>npm i cookie-parser (npm package) --- https://www.npmjs.com/package/cookie-parser
                <br>para utilizá-lo no site, no index.js é usado
                <br>const cookieParser = require('cookie-parser');
                <br>app.use(cookieParser());
                <br>agora todas as solicitações tem acesso aos cookies enviados pela página, que foram armazenados no
                browser, independente se os dados do cookie são de acordos com o usuário ou criados pelo site
                <br>app.get('/greet', (req, res) =&gt; {
                <br> const {name = 'No-name'} = req.cookies;
                <br> res.send(`Hey There ${name}!`)
                <br>})
                <br>
                <br>
                <br>signing cookies
                <br>garantir que os dados originais que foram enviados ao cliente, são os mesmos que estão sendo
                enviados ao servidor
                <br>para isso o cookie parser precisa de um argumento, e na função em que o cookie é enviado é
                necessário ter a opção singed definida como true
                <br>app.use(cookieParser('secret'));
                <br>app.get('/getsignedcookie', (req, res) =&gt; {
                <br> res.cookie('fruit', 'grape', {signed: true});
                <br> res.send('ok, send you signed cookie!')
                <br>})
                <br>não se trata de esconder os dados, somente para garantir que os dados são os mesmos
                <br>os cookies com assinaturas digitais não são armazenados em cookies, e sim em signedCookies, para
                tornar possível diferenciá-los
                <br>se o usuário fizer alguma alteração no cookie assinado, ele não será mais um cookie assinado, devido
                ao fato de que ele foi modificado e não é possível verificar sua integridade
                <br>
                <br>
                <br>HMAC Signing
                <br>não é uma assinatura exclusiva para cookies, é usada em criptomoedas por exemplo, e é fundamental
                para o seu funcionamento
                <br>como funciona um processo de assinatura digital
                <br>(sometimes expanded as either keyed-hash message authentication code or hash-based message
                authentication code)
                <br>specific type of message authentication code (MAC) involving a cryptographic hash function and a
                secret cryptographic key. As with any MAC, it may be used to simultaneously verify both the data
                integrity and authenticity of a message.
                <br>documentação aprofundada em assinaturas digitais
                <br>documentação HMAC wikipedia --- https://en.wikipedia.org/wiki/HMAC
                <br>HMAC generator/tester tool --- https://www.freeformatter.com/hmac-generator.html
                <br>source code using cookie signature ---
                https://github.com/expressjs/cookie-parser/blob/master/index.js
            </p>
            <h3>Express Session & Flash</h3>
            <p>
                introduction to sessions
                <br>npm package - https://www.npmjs.com/package/express-session
                <br>npm i express-session
                <br>sessions, what are they?
                <br>it's not very practical(or secure) to store a lot of data client-side using cookies. This is where
                sessions come in! Sessions are a server-side data store that we use to make HHTP stateful. Instead of
                storing data using cookies, we store the data on the server-side and then send the browser a cookie that
                can be used to retrieve the data. a diagram might be helpful here
                <br>semelhante a ideia de cookies, mas armazena as informações do lado do servidor
                <br>o servidor armazena as informações com um tipo de id/chave para acessar essas informações, e envia
                para o navegador um cookie capaz de acessar essas informações
                <br>os ids são associados ao usuário que está fazendo o armazenamento das informações, e através do
                cookie enviado para o cliente, o cliente recebe os dados do servidor através da sessão armazenada
                <br>mais seguro, e os cookies tem um limite de informações a ser guardadas, o que torna sessions muito
                mais útil
                <br>o primeiro passo é definir um middleware que será utilizado para atribuir dados do servidor a um
                browser, exempo:
                <br>app.use(session({ secret: 'thisisnotagoodsecret' }))
                <br>após definir o middleware de session, o cookie "connect.sid" (session id) recebe um valor assinado
                para saber se foi adulterado, esse id associa o navegador de quem recebeu o cookie, para um espaço de
                armazenamento de memória no servidor, que irá assimilar os dados
                <br>para armazenar alguma informação no server-side utilizando session, é utilizado "req.session", ex:
                <br>app.get('/viewcount', (req, res) =&gt; {
                <br> if (req.session.count) {
                <br> req.session.count += 1;
                <br> } else {
                <br> req.session.count = 1;
                <br> }
                <br> res.send(`You have viewed this page ${req.session.count} times!`)
                <br>})
                <br>definindo as opções no middleware para não ter avisos no terminal, e utilizar session da melhor
                forma:
                <br>const sessionOptions = { secret: 'thisisnotagoodsecret', resave: false }
                <br>app.use(session(sessionOptions))
                <br>
                <br>
                <br>
                <br>
                <br>
                <br>intro to flash
                <br>npm package --- https://github.com/jaredhanson/connect-flash
                <br>npm i connect-flash
                <br>a ideia do flash é basicamente um local na sessão para enviar uma mensagem flash para o usuário,
                como uma mensagem de sucesso/confirmação ou falha uma vez, e depois disso ela some
                <br>para importar flash no documento:
                <br>const flash = require('connect-flash');
                <br>app.use(flash());
                <br>agora todas as rotas tem a função req.flash, que pode ser usado utilizando uma categoria de
                mensagem, e a mensagem, para um feedback ao usuário
                <br>req.flash('success', 'Successfully message here!');
                <br>para renderizar no documento em ejs, é só utilizar na rota o parâmetro
                <br>{ messages: req.flash('success') }
                <br>dessa maneira, fica possível acessar no documento ejs &lt;%=messages%&gt;
                <br>uma maneira de mostrar um feedback rápido, que não será exibido novamente, logged in, logged out,
                welcome back, etc
                <br>
                <br>
                <br>res.local & flash
                <br>para não utilizar "{ messages: req.flash('success') }" em todas as rotas, existe uma maneira
                utilizando um middleware
                <br>app.use((req, res, next) => {
                <br> res.locals.messages = req.flash('success');
                <br> next();
                <br>})
                <br>dessa maneira, todos os arquivos ejs em views, terão acesso a messsages, sem a necessidade de
                definir o que será utilizado em todas as rotas
                <br>é comum definir também de acordo com a categoria, res.locals.success, res.locals.errors, tendo assim
                também um feedback caso haja algum erro
            </p>
            <h3>Authentication From "Scratch"</h3>
            <p>
                authentication vs authorization
                <br>authentication
                <br>what is it?
                <br>authentication is the process of veryfying who a particular user is. we typically authenticate with
                a username/password combo, but we can also use security questions, facial recognition, etc
                <br>
                <br>authorization
                <br>what is it?
                <br>authorization is veryfing a specific user has access to. generally, we authorize after a user has
                been authenticated. Now that we know who you are, here is what you are allowed to do and NOT allowed to
                do
                <br>
                <br>autenticação identifica o usuário, autorização define o que o usuário autenticado pode fazer, se ele
                é um moderador, etc
                <br>
                <br>
                <br>how to (not) store a password
                <br>rule#1 never store passwords
                <br>{
                <br>username: 'kittycatluvr'
                <br>password: 'meowmeow999'
                <br>}
                <br>não salvar as senhas no banco de dados, pois se alguém acessar o banco de dados terá as informações
                do usuário, que se tiver várias contas com a mesma senha em vários site, será hackeado em várias contas
                <br>para isso, a solução é o hashing
                <br>
                <br>hashing, the solution!
                <br>rather than storing a password in the database, we run the password through a hashing function first
                and then store the result in the database, hashing functions are functions that map input data of some
                arbitrary size to fixed-size output values
                <br>é uma maneira de "criptografar" a senha, que é armazenada no banco de dados
                <br>a função basicamente transforma a entrada inserida pelo usuário (senha), em um código que sempre
                terá o mesmo número de caracteres, independendo do número de caracteres na entrada
                <br>dessa forma, o armazenamento de senhas no banco de dados com a função hashing ficaria algo como:
                <br>{
                <br>username: 'kittycatluvr'
                <br>password: 'd7offoab9a23ec5dba9o75boe4dede8c2972ba933d6d5adf3a42abb6eod7a2da'
                <br>}
                <br>existem vários tipos e grupos de hashing functions, mas eles não tem a ver com criptografia
                <br>nem todas as funções hash são apropriadas para armazenar senhas por esse motivo, existem funções
                hashs específicas para o armazenamento de senhas no banco de dados
                <br>
                <br>
                <br>cryptographic hash functions
                <br>1. one-way function which is infeasible to invert
                <br>2. small change in input yields large change in the output
                <br>3. deterministic-same input yields same output
                <br>4. unlikely to find 2 outputs with same value
                <br>5. password hash functions are deliberately slow
                <br>documentação na wikipedia --- https://en.wikipedia.org/wiki/Cryptographic_hash_function
                <br>
                <br>
                <br>sem utilizar nenhum método adicional, a função de hash apenas criará uma saída de acordo com a
                entrada, porém se a entrada for igual, a saída será igual, e devido a isso usuários que compartilham a
                mesma senha, caso uma for descoberta por alguém com acesso ao banco de dados, o hash pode ser assimilado
                com a entrada da senha, e assim todos os usuários com essa senha poderão ter suas contas invadidas
                <br>por esse motivo se torna muito útil o uso de "salts", para mesmo se usuário tiverem a mesma senha, o
                seu hash armazenado no banco de dados será diferente, para evitar esse tipo de ataque, que é muito comum
                (existem inclusive sites mostrando listas de senhas mais comuns utilizadas, que são forçadas
                continuamente por usuários mal intencionados tentando invadí-las)
                <br>salts, an extra safeguard
                <br>é um passo a mais quando estamos fazendo hash de uma senha, para tornar mais difícil ainda de
                adivinhá-la
                <br>a salt is a random value added to the password before we hash it, it helps ensure unique hashes and
                mitigate common attacks
                <br>"salt" pode ser utilizado a partir de uma biblioteca utilizada no código
                <br>os salts são adicionados na entrada (senha inserida pelo usuário), devido ao fato de que a saída
                muda radicalmente com pequenas alterações na entrada
                <br>o salt precisa ser armazenado também, pois se o usuário tenta fazer login no site, o site irá
                adicionar o salt criado para procurar a sua autenticação no banco de dados
                <br>desa maneira invasores não conseguem utilizar uma tabela pré-computada, devido ao fato de que eles
                não tem acesso aos salts, apenas tentarão forçar a senha para descobrir apenas uma, e não outras senhas
                iguais, pois o salt das duas será dois valores aleatórios diferentes
                <br>
                <br>
                <br>intro to Bcrypt
                <br>documentação na wikipedia --- https://en.wikipedia.org/wiki/Bcrypt
                <br>node.bcrypt.js --- https://www.npmjs.com/package/bcrypt (npm install bcrypt)
                <br>bcrypt.js --- https://www.npmjs.com/package/bcryptjs (npm install bcryptjs)
                <br>"node.bcrypt.js" é escrito em cima do C++, o que o torna mais rápido, executado no lado do servidor
                <br>"bcrypt.js" é escrito inteiramente em JavaScript, é executado no lado do cliente, no browser
                <br>npm i bcrypt
                <br>
                <br>const bcrypt = require('bcrypt');
                <br>
                <br>// função gerando o salt e depois adicionando ao hash
                <br>const hashPassword = async (pw) => {
                <br> const salt = await bcrypt.genSalt(12);
                <br> const hash = await bcrypt.hash(pw, salt);
                <br> console.log(salt);
                <br> console.log(hash);
                <br>}
                <br>// cria um salt com 12 rounds, e faz a função hash separado, depois printa só o salt, e o resultado
                <br>
                <br>// função gerando o salt já adicionando o hash
                <br>const hashPassword = async (pw) =&gt; {
                <br> const hash = await bcrypt.hash(pw, 12);
                <br> console.log(hash);
                <br>}
                <br>// cria um salt com 12 rounds, faz o hash do valor inserido (pw) e no final printa o resultado
                <br>
                <br>const login = async (pw, hashedPw) =&gt; {
                <br> const result = await bcrypt.compare(pw, hashedPw)
                <br> if (result) {
                <br> console.log('Logged in successfully!')
                <br> } else {
                <br> console.log('Incorrect password... try again.')
                <br> }
                <br>}
                <br>// função para verificar se a senha inserida está de acordo com o que foi armazenado
                <br>
                <br>
                <br>auth demo: a simple express app using authentication of bcrypt and other useful codes
                <br>
                <br>app.post('/register', async (req, res) => {
                <br> const { username, password } = req.body;
                <br> const hash = await bcrypt.hash(password, 12)
                <br> const user = new User({
                <br> username,
                <br> password: hash
                <br> })
                <br> await user.save();
                <br> req.session.user_id = user._id;
                <br> res.redirect('/')
                <br>})
                <br>// rota para registrar o usuário no banco de dados com a senha depois do hash
                <br>
                <br>app.post('/login', async (req, res) => {
                <br> const { username, password } = req.body;
                <br> const user = await User.findOne({ username });
                <br> const validPassword = await bcrypt.compare(password, user.password);
                <br> if (validPassword) {
                <br> req.session.user_id = user._id;
                <br> res.redirect('/secret')
                <br> } else {
                <br> res.redirect('/login')
                <br> }
                <br>})
                <br>// rota para verificar no banco de dados as credenciais inseridas pelo usuário (login)
                <br>
                <br>armazenando se o usuário está logado através do express-session:
                <br>req.session.user_id = user._id;
                <br>é importante usar esse id de usuário para no caso de comentário, posts e etc desse mesmo usuário, o
                id dele será assimilado
                <br>
                <br>logout feito com uma página que joga uma solicitação POST para uma rota, que desloga e redireciona
                <br>app.post('/logout', (req, res) => {
                <br> req.session.user_id = null;
                <br> res.redirect('/login')
                <br>})
                <br>// dessa maneira, somente o user_id será definido como NULL, existe a maneira de deletar tudo da
                sessão do usuário, através de "req.session.destroy();", ex:
                <br>
                <br>app.post('/logout', (req, res) => {
                <br> req.session.destroy();
                <br> res.redirect('/login')
                <br>})
                <br>
                <br>
                <br>require login middleware:
                <br>const requireLogin = (req, res, next) => {
                <br> if (!req.session.user_id) {
                <br> return res.redirect('/login')
                <br> }
                <br>}
                <br>para usar o middleware nas rotas, é só adicionar a função criada:
                <br>app.get('/secret', requireLogin, (req, res) => {
                <br> res.render('secret')
                <br>})
                <br>
                <br>
                <br>alguns encurtamentos no código
                <br>/login post route
                <br>é possível fazer o processo que acha o usuário e valida a senha ( de duas estapas ) em uma etapa,
                criando um método no modelo de User, após adicionar bcrypt ao model:
                <br>const bcrypt = require('bcrypt');
                <br>userSchema.statics.findAndValidate = async function (username, password) {
                <br> const foundUser = await this.find({ username });;
                <br> const isValid = await bcrypt.compare(password, foundUser.password)
                <br> return isValid ? foundUser : false
                <br>}
                <br>dessa forma, a rota pode ser dimnuída para:
                <br>app.post('/login', async (req, res) => {
                <br> const { username, password } = req.body;
                <br> const foundUser = await User.findAndValidate(username, password)
                <br> if (foundUser) {
                <br> req.session.user_id = foundUser._id;
                <br> res.redirect('/secret')
                <br> } else {
                <br> res.redirect('/login')
                <br> }
                <br>})
                <br>
                <br>também é possível eliminar a função que faz o hash da senha antes de salvá-la na rota, sendo
                utilizado no lugar para salvar um middleware, definido no modelo do User:
                <br>userSchema.pre('save', async function (next) {
                <br> if (!this.isModified('password')) return next();
                <br> this.password = await bcrypt.hash(this.password, 12)
                <br> next();
                <br>})
                <br>dessa forma, a rota pode ser diminuida para:
                <br>app.post('/register', async (req, res) => {
                <br> const { username, password } = req.body;
                <br> const user = new User({ username, password })
                <br> await user.save();
                <br> req.session.user_id = user._id;
                <br> res.redirect('/')
                <br>})
                <br>ainda não tem relação com erros e etc
            </p>
            <hr>
            <section style="color: #FF0000; background-color: #C8C8C8;">
                <h2 style="text-align: center;">YelpCamp: A Massive Project Using all of the learned stuff</h2>
                <h4 style="text-align: center;">(inline styles are being used here for don't need to create a .CSS)</h3>
                    <h4 style="text-align: center;">/d/web development/0 Outros/24 YelpCamp/</h4>
                    <h3>Campgrounds CRUD</h3>
                    <p>
                        YelpCamp, our massive project
                        <br>first pass, just maked a full CRUD application for campgrounds
                        <br>a ordem dos app.gets importa, se tiver um app.get('/index/new') e um app.get('/index/:id'),
                        o new precisa vir antes do id, pois se vir depois, ele será um erro, onde procurará o id "new" e
                        não encontrará
                    </p>
                    <h3>Adding Basic Styles</h3>
                    <p>
                        ejs-mate, npm package to simplify partials including process
                        <br>npm i ejs-mate
                        <br>const ejsMate = require('ejs-mate');
                        <br>app.engine('ejs', ejsMate)
                        <br>após definir esses parâmetros, é criado dentro da pasta views a pasta "layouts", contendo o
                        arquivo "boilerplate.ejs"
                        <br>dentro do arquivo boilerplate.ejs, o código será ! + TAB, e dentro de body, a função
                        <br>&lt;%- body %&gt;
                        <br>e nos arquivos já criados, se apaga tudo, deixando somente o conteúdo que estava dentro de
                        body, e utiliza-se no topo do documento a função:
                        <br>&lt;% layout('layouts/boilerplate') %&gt;
                        <br>dessa maneira torna mais fácil adicionar estilos, JavaScript, e etc, modificando somente o
                        arquivo boilerplate, como se fosse vários partials adicionados agrupados em um só arquivo
                        <br>além de usar o boilerplate, itens como navbars, footes e alguns outros são adicionados em
                        partials, assim tornando o boilerplate limpo de códigos desnecessários
                        <br>lembrando que para incluir um arquivo dentro de "views/partials/.ejs", o comando é:
                        <br>&lt;%-include('../partials/navbar')%&gt;
                        <br>api de imagens do unsplash, , o número é o id
                        da coleção de imagens
                    </p>
                    <h3>Errors & Validating Data</h3>
                    <p>
                        client-side form validations
                        <br>dentro da input escrita em html é possível adicionar "required" para que seja necessário ter
                        algum valor dentro da entrada, validação feita pelo browser
                        <br>utilizando validações de formulário com o bootstrap
                        <br>após inserir required em todos os campos, no form, é inserido "novalidate" para evitar o
                        procedimento padrão
                        <br>adicionar a classe "validated-form" no formulário
                        <br>e adicionar o script do bootstrap (na documentação do site)
                        <br>&lt;script&gt;
                        <br> // Example starter JavaScript for disabling form submissions if there are invalid fields
                        <br> (function () {
                        <br> 'use strict'
                        <br> // Fetch all the forms we want to apply custom Bootstrap validation styles to
                        <br> const forms = document.querySelectorAll('.validated-form')
                        <br> // Loop over them and prevent submission
                        <br> Array.from(forms)
                        <br> .forEach(function (form) {
                        <br> form.addEventListener('submit', function (event) {
                        <br> if (!form.checkValidity()) {
                        <br> event.preventDefault()
                        <br> event.stopPropagation()
                        <br> }
                        <br> form.classList.add('was-validated')
                        <br> }, false)
                        <br> })
                        <br> })()
                        <br>&lt;/script&gt;
                        <br>é possível adicionar um feedback para o usuário dentro das inputs, inserido através de um
                        div com a classe "valid-feedback"
                        <br>&lt;div class="valid-feedback"&gt;
                        <br> Looks good!
                        <br>&lt;/div&gt;
                        <br>diretório utils para utilitários, evitando o excesso de código dentro do arquivo principal
                        <br>utilitário "catchAsync.js";
                        <br>module.exports = func =&gt; {
                        <br> return (req, res, next) =&gt; {
                        <br> func(req, res, next).catch(next);
                        <br> }
                        <br>}
                        <br>
                        <br>utilitário "ExpressError.js";
                        <br>class ExpressError extends Error {
                        <br> constructor(message, statusCode){
                        <br> super();
                        <br> this.message = message;
                        <br> this.statusCode = statusCode;
                        <br> }
                        <br>}
                        <br>module.exports = ExpressError;
                        <br>
                        <br>para adicionar os utilitários no programa principal,
                        <br>const catchAsync = require('./utils/catchAsync');
                        <br>const ExpressError = require('./utils/ExpressError');
                        <br>
                        <br>utilizando no app.js a função utilitária criada em utils/catchAsync.js, agora não é
                        necessário escrever em toda função assíncrona o try e o catch, é só utilizar a função antes da
                        rota, ficando de maneira:
                        <br>app.get('/campgrounds/:id', catchAsync(async (req, res) =&gt; {
                        <br> const campground = await Campground.findById(req.params.id)
                        <br> res.render('campgrounds/show', { campground })
                        <br>}));
                        <br>
                        <br>mesmo ao fazer esses handle erros para que não seja possível enviar o formulário com campos
                        vazios, ou algum outro erro, ainda é possível criar um campground sem os valores, utilizando o
                        postman por exemplo
                        <br>é possível utilizar o código:
                        <br>if (!req.body.campground) throw new ExpressError('Invalid Campground', 400);
                        <br>antes das funções assíncronas para corrigir esse erro, e se alguém tentar enviar esses dados
                        fora do formulário vai receber uma "página" de erro
                        <br>
                        <br>para definir um template para erros, um error.ejs é criado no diretório views, e nele é
                        usado um alerta de bootstrap, e o boilerplate utilizado nos arquivos ejs, para manter o padrão
                        da página
                        <br>dentro do app.js, é possível fazer com que a mensagem fique utilizável no ejs a partir de:
                        <br>app.use((err, req, res, next) =&gt; {
                        <br> const { statusCode = 500 } = err;
                        <br> if (!err.message) err.message = 'Oh No, Something went wrong!'
                        <br> res.status(statusCode).render('error', { err });
                        <br>});
                        <br>e dentro do arquivo error.ejs em views, é possível acessar o erro através de:
                        <br>&lt;%=err.message%&gt;
                        <br>
                        <br>JOI schema validation
                        <br>documentation: https://joi.dev/api/?v=17.6.0
                        <br>da maneira atual, somente o título do campground se torna totalmente obrigatório ao ser
                        validado e enviar através do postman, por exemplo, só que não é necessário fazer vários if!req.
                        etc e essa lógica, que é algo que não funciona em aplicações maiores, e não é nem um pouco
                        recomendado
                        <br>para isso é utilizado o joi, que faz a validação dos dados no lado do servidor, para caso o
                        usuário tente forçar os dados através de um meio externo como o postman, seja bloqueado do mesmo
                        jeito
                        <br>código dentro de adicionar um novo campground com console log, para fins de desenvolvimento:
                        <br>const campgroundSchema = Joi.object({
                        <br> campground: Joi.object({
                        <br> title: Joi.string().required(),
                        <br> price: Joi.number().required().min(0),
                        <br> image: Joi.string().required(),
                        <br> location: Joi.string().required(),
                        <br> description: Joi.string().required()
                        <br> }).required()
                        <br>})
                        <br> const {error} = campgroundSchema.validate(req.body);
                        <br> if(error){
                        <br> const msg = error.details.map(el =&gt; el.message).join(',');
                        <br> throw new ExpressError(msg, 400)
                        <br>}
                        <br>console.log(result);
                        <br>
                        <br>função criada para ser usada de middleware em todas as rotas em que for necessário validar
                        os campos de entrada do campground
                        <br>const validateCampground = (req, res, next) =&gt; {
                        <br> const campgroundSchema = Joi.object({
                        <br> campground: Joi.object({
                        <br> title: Joi.string().required(),
                        <br> price: Joi.number().required().min(0),
                        <br> image: Joi.string().required(),
                        <br> location: Joi.string().required(),
                        <br> description: Joi.string().required()
                        <br> }).required()
                        <br> })
                        <br> const { error } = campgroundSchema.validate(req.body);
                        <br> if (error) {
                        <br> const msg = error.details.map(el =&gt; el.message).join(',');
                        <br> throw new ExpressError(msg, 400)
                        <br> } else {
                        <br> next();
                        <br> }
                        <br>}
                        <br>para eliminar o excesso de código no arquivo principal, é criado o arquivo schemas.js,
                        contendo:
                        <br>const Joi = require('joi');
                        <br> module.exports.campgroundSchema = Joi.object({
                        <br> campground: Joi.object({
                        <br> title: Joi.string().required(),
                        <br> price: Joi.number().required().min(0),
                        <br> image: Joi.string().required(),
                        <br> location: Joi.string().required(),
                        <br> description: Joi.string().required()
                        <br> }).required()
                        <br>});
                        <br>
                        <br>dessa forma, a função criada no arquivo principal ficará somente:
                        <br>const validateCampground = (req, res, next) =&gt; {
                        <br> const { error } = campgroundSchema.validate(req.body);
                        <br> if (error) {
                        <br> const msg = error.details.map(el =&gt; el.message).join(',');
                        <br> throw new ExpressError(msg, 400)
                        <br> } else {
                        <br> next();
                        <br> }
                        <br>}
                    </p>
                    <h3>Adding The Reviews Model</h3>
                    <p>
                        modificação com um novo formulário em show.ejs, definição da rota no arquivo app.js, validação
                        utilizando client-side (novalidate e class="validated-form" no form e required na input
                        textarea), trocar o script da função de validação das páginas ejs "edit" e "new" para o
                        boilerplate, para que não seja necessário repetir a mesma função em 3 documentos diferentes, e
                        adição do div com a classe valid-feedback para dar uma resposta ao usuário se o campo estiver
                        completado corretamente, e validação do lado do servidor, utilizando o mesmo arquivo schemas.js,
                        adicionando o código:
                        <br>module.exports.reviewSchema = Joi.object({
                        <br> review: Joi.object({
                        <br> rating: Joi.number().required()min(1).max(5),
                        <br> body: Joi.string().required()
                        <br> }).required()
                        <br>});
                        <br>após criar a validação do lado do servidor, adicionar no app.js, podendo utilizar a mesma
                        linha já criada:
                        <br>const { campgroundSchema, reviewSchema } = require('./schemas.js');
                        <br>após isso, criar o middleware de validação de review, utilizando:
                        <br>const validateReview = (req, res, next) =&gt; {
                        <br> const { error } = reviewSchema.validate(req.body);
                        <br> if (error) {
                        <br> const msg = error.details.map(el =&gt; el.message).join(',');
                        <br> throw new ExpressError(msg, 400)
                        <br> } else {
                        <br> next();
                        <br> }
                        <br>};
                        <br>depois de criar o middleware, adicioná-lo a rota de review:
                        <br>app.post('/campgrounds/:id/reviews', validateReview, catchAsync(async (req, res) =&gt;
                        {func}
                        <br>popular os reviews no campground:
                        <br>app.get('/campgrounds/:id', catchAsync(async (req, res) =&gt; { const campground = await
                        Campground.findById(req.params.id).populate('reviews'); + func etc}
                        <br>basicamente o que mostra os reviews é:
                        <br>&lt;%for(let review of campground.reviews) {%>
                        <br> &lt;div class="card mb-3 "&gt;
                        <br> &lt;div class="card-body"&gt;
                        <br> &lt;h5 class="card-title"&gt;Rating: &lt;%=review.rating%&gt;&lt;/h5&gt;
                        <br> &lt;p class="card-text"&gt;Review: &lt;%=review.body%&gt;&lt;/p&gt;
                        <br> &lt;/div&gt;
                        <br> &lt;/div&gt;
                        <br>&lt;%}%&gt;
                        <br>para deixar a página mais estilizada, é criado um col-6 div para que os comentários fiquem a
                        direita, e algumas propriedades visuais
                        <br>formulário de exclusão criado para cade review:
                        <br>&lt;form
                        action="/campgrounds/&lt;%=campground._id%&gt;/reviews/&lt;%=review._id%>?_method=DELETE"
                        method="POST"&gt;
                        <br> &lt;button class="btn btn-sm btn-danger"&gt;Delete&lt;/button&gt;
                        <br>&lt;/form&gt;
                        <br>rota de exclusão no app.js:
                        <br>app.delete('/campgrounds/:id/reviews/:reviewId', catchAsync(async (req, res) =&gt; {
                        <br> const { id, reviewId } = req.params;
                        <br> await Campground.findByIdAndUpdate(id, {$pull: {reviews: reviewId}});
                        <br> await Review.findByIdAndDelete(reviewId);
                        <br> res.redirect(`/campgrounds/${id}`);
                        <br>}));
                        <br>$pull é utilizado para remover um objeto com id dentro de um objeto com id, otimização
                        <br>campground mongoose deletion middleware: no caso de deletar um campground, todos os seus
                        reviews deverão ser excluídos, no campground.js antes de exportar
                        <br>CampgroundSchema.post('findOneAndDelete', async function (doc) {
                        <br> if (doc) {
                        <br> await Review.deleteMany({
                        <br> _id: {
                        <br> $in: doc.reviews
                        <br> }
                        <br> })
                        <br> }
                        <br>});
                    </p>
                    <h3>Restructuring & Flash</h3>
                    <p>
                        criação de um diretório de routes para separar as rotas de /campgrounds
                        <br>dentro do diretório routes, campgrounds.js, contendo as rotas, que tem o app.method,
                        alterado para router.method
                        <br>no topo do arquivo é necessário informar:
                        <br>const express = require('express');
                        <br>const router = express.Router();
                        <br>e também todas os outros elementos utilizados no código, como modelos, funções, etc:
                        <br>const catchAsync = require('../utils/catchAsync');
                        <br>const ExpressError = require('../utils/ExpressError');
                        <br>const Campground = require('../models/campground');
                        <br>no final do arquivo campgrounds.js, é exportado através de:
                        <br>module.exports = router;
                        <br>para adicionar o arquivo no app.js, é usado:
                        <br>const campgrounds = require('./routes/campgrounds');
                        <br>no arquivo app.js, é definido o uso das routes do campground por:
                        <br>app.use('/campgrounds', campgrounds);
                        <br>mesma coisa para reviews, as rotas de reviews irão para reviews.js dentro de routes, para
                        simplificar os reviews, é possível colocar para que as rotas comecem com um prefixo maior:
                        <br>app.use('/campgrounds/:id/reviews', reviews);
                        <br>após deixar os arquivos de routes bem separados, é uma boa prática deixar o código do app.js
                        o mais limpo possível
                        <br>as rotas separadas definidas através do router não tem acesso aos params do resto, somente
                        da sua rota, para ele possuir acesso é necessário utilizar uma configuração chamada mergeParams,
                        definido no arquivo router:
                        <br>const router = express.Router({mergeParams: true});
                        <br>diretório public contendo alguns elementos que possibilitam reduzir o código dentro do
                        boilerplate, como a função de validateForms, e é utilizano no app.js um método para acessar esse
                        diretório:
                        <br>app.use(express.static(path.join(__dirname, 'public')));
                        <br>envio de cookies utilizando express-session
                        <br>utilização de flash para feedback ao usuário
                        <br>instalar e adicionar o flash, definição da mensagem, middleware de flash, estilização do
                        flash
                    </p>
                    <h3>Adding In Authentication</h3>
                    <p>
                        Passport documentation - http://www.passportjs.org/
                        <br>npm i passport passport-local passport-local-mongoose
                        <br>criar o modelo do usuário, especificando somente o email, string required unique
                        <br>adicionar o código:
                        <br>UserSchema.plugin(passportLocalMongoose);
                        <br>definirá senha, métodos para usuários, impedir que usuários sejam repetidos, etc:
                        <br>
                        <br>const mongoose = require('mongoose');
                        <br>const Schema = mongoose.Schema;
                        <br>const passportLocalMongoose = require('passport-local-mongoose');
                        <br>const UserSchema = new Schema({
                        <br> email: {
                        <br> type: String,
                        <br> required: true,
                        <br> unique: true
                        <br> }
                        <br> });
                        <br>UserSchema.plugin(passportLocalMongoose);
                        <br>module.exports = mongoose.model('User', UserSchema);
                        <br>
                        <br>configuring passport
                        <br>code lines:
                        <br>const user = require('./models/user');
                        <br>const passport = require('passport');
                        <br>const LocalStrategy = require('passport-local');
                        <br>app.use(passport.initialize());
                        <br>app.use(passport.session()); // precisa vir depois de session
                        <br>passport.use(new LocalStrategy(User.authenticate()));
                        <br>passport.serializeUser(User.serializeUser());
                        <br>passport.deserializeUser(User.deserializeUser());
                        <br>é possível criar uma rota só para visualizar como é a criação de um usuário, feita a partir
                        de:
                        <br>app.get('/makeFakeUser', async (req, res) =&gt; {
                        <br> const user = new User({email: 'neiva@gmail.com', username: 'neeiva'});
                        <br> const newUser = await User.register(user, 'senha');
                        <br> res.send(newUser);
                        <br>});
                        <br>basic registration form ejs:
                        <br>&lt;h1&gt;Register&lt;/h1&gt;
                        <br> &lt;form action="/register" method="POST" class="validated-form" novalidate&gt;
                        <br> &lt;div class="mb-3"&gt;
                        <br> &lt;label class="form-label" for="username"&gt;Username&lt;/label&gt;
                        <br> &lt;input class="form-control" id="username" type="text" name="username"
                        placeholder="Username" required&gt;
                        <br> &lt;div class="valid-feedback"&gt;
                        <br> Looks good!
                        <br> &lt;/div&gt;
                        <br> &lt;div class="mb-3"&gt;
                        <br> &lt;label class="form-label" for="email"&gt;Email&lt;/label&gt;
                        <br> &lt;input class="form-control" id="email" type="email" name="email" placeholder="Email"
                        required&gt;
                        <br> &lt;div class="valid-feedback"&gt;
                        <br> Looks good!
                        <br> &lt;/div&gt;
                        <br> &lt;div class="mb-3"&gt;
                        <br> &lt;label class="form-label" for="password"&gt;Password&lt;/label&gt;
                        <br> &lt;input class="form-control" id="password" type="password" name="password"
                        placeholder="Password" required&gt;
                        <br> &lt;div class="valid-feedback"&gt;
                        <br> Looks good!
                        <br> &lt;/div&gt;
                        <br> &lt;button class="btn btn-success"&gt;Register&lt;/button&gt;
                        <br>&lt;/form&gt;
                        <br>basic registration route:
                        <br>router.post('/register', catchAsync(async (req, res) =&gt; {
                        <br> try {
                        <br> const { email, username, password } = req.body;
                        <br> const user = await new User({ email, username });
                        <br> const registeredUser = await User.register(user, password);
                        <br> req.flash('success', 'Welcome to Yelp Camp!');
                        <br> res.redirect('/campgrounds');
                        <br> } catch (e) {
                        <br> req.flash('error', e.message);
                        <br> res.redirect('register');
                        <br>}
                        <br>login route (login form copy of register form):
                        <br>router.post('/login', passport.authenticate('local', { failureFlash: true, failureRedirect:
                        '/login' }), catchAsync(async (req, res) =&gt; {
                        <br> req.flash('success', 'Welcome back!');
                        <br> res.redirect('/campgrounds');
                        <br>}));
                        <br>é possivel usar "isAuthenticated()", que vem do próprio passport, para desenvolver:
                        <br>router.get('/new', (req, res) => {
                        <br> if(!req.isAuthenticated()) {
                        <br> req.flash('error', 'You must be signed in!');
                        <br> return res.redirect('/login');
                        <br> }
                        <br> res.render('campgrounds/new');
                        <br>});
                        <br>ao invés de utilizar na rota, o ideal é utilizar um middleware, para impossibilitar por
                        exemplo, solicitações feitas através do postman
                        <br>middleware.js, dentro do diretório raíz:
                        <br>module.exports.isLoggedIn = (req, res, next) =&gt; {
                        <br> if (!req.isAuthenticated()) {
                        <br> req.flash('error', 'You must be signed in first!');
                        <br> return res.redirect('/login');
                        <br> }
                        <br> next();
                        <br>}
                        <br>dentro das rotas de campgrounds:
                        <br>const { isLoggedIn } = require('../middleware');
                        <br>e para utilizar, basta inserir o middleware na rota:
                        <br>router.get('/new', isLoggedIn, (req, res) =&gt; { func }
                        <br>não verifica quem é o usuário e nem se ele é um autor/administrador, apenas garante que
                        alguém está logado
                        <br>para dar a funcionalidade de logout, basta utilizar "req.logout()", do passport:
                        <br>router.get('/logout', catchAsync(async (req, res) =&gt; {
                        <br> req.logout();
                        <br> req.flash('success', 'Successfully signed out. Good bye!')
                        <br> res.redirect('/campgrounds');
                        <br>}));
                        <br>o ideal é fazer também com que os botões onde o usuário precisa estar logado para fazer uma
                        ação, sumam quando não tiver um usuário conectado
                        <br>navbar ejs partial:
                        <br>&lt;div class="navbar-nav ml-auto"&gt;
                        <br> &lt;a class="nav-link" href="/login"&gt;Login&lt;/a&gt;
                        <br> &lt;a class="nav-link" href="/register"&gt;Register&lt;/a&gt;
                        <br> &lt;a class="nav-link" href="/logout"&gt;Logout&lt;/a&gt;
                        <br>&lt;/div&gt;
                        <br>para fazer a exibição dinâmica dos itens, no app.use onde é definido os flashs 'error' e
                        'success', é adicionado ao topo do código uma linha para atribuir o usuário em todas as páginas
                        da aplicação:
                        <br>res.locals.currentUser = req.user;
                        <br>dessa forma, os arquivos ejs terão acesso à essa propriedade, que pode ser usada como
                        display utilizando a função "if(!currentUser) {"
                        <br>assim, o navbar partial ficará da seguinte forma:
                        <br>&lt;div class="navbar-nav ml-auto"&gt;
                        <br> &lt;%if(!currentUser) {%&gt;
                        <br> &lt;a class="nav-link" href="/login"&gt;Login&lt;/a&gt;
                        <br> &lt;a class="nav-link" href="/register"&gt;Register&lt;/a&gt;
                        <br> &lt;%} else {%&gt;
                        <br> &lt;a class="nav-link" href="/logout"&gt;Logout&lt;/a&gt;
                        <br> &lt;%}&gt;
                        <br>&lt;/div&gt;
                        <br>para que um usuário que acabou de se registrar já entre no site sem precisar fazer o login,
                        é necessário alterar o código da rota de register, em users.js, ficando da maneira:
                        <br>router.post('/register', catchAsync(async (req, res) =&gt; {
                        <br> try {
                        <br> const { email, username, password } = req.body;
                        <br> const user = await new User({ email, username });
                        <br> const registeredUser = await User.register(user, password);
                        <br> req.login(registeredUser, err =&gt; {
                        <br> if (err) return next(err);
                        <br> req.flash('success', 'Welcome to Yelp Camp!');
                        <br> res.redirect('/campgrounds');
                        <br> });
                        <br> } catch (e) {
                        <br> req.flash('error', e.message);
                        <br> res.redirect('register');
                        <br> }
                        <br>}));
                        <br>um usuário que não está logado, ao tentar criar um novo acampamento, é redirecionado a
                        página de login, e ao realizar o login, ele é redirecionado para todos os acampamentos, e não
                        para a página de criação de acampamento em que ele estava, é possível consertar isso
                        "rastreando" onde o usuário estava antes de ser redirecionado para a página de login
                        <br>para resolver a situação, é necessário algumas linhas de código
                        <br>em middleware.js:
                        <br>module.exports.isLoggedIn = (req, res, next) =&gt; {
                        <br> if (!req.isAuthenticated()) {
                        <br>req.session.returnTo = req.originalUrl;
                        <br> req.flash('error', 'You must be signed in first!');
                        <br> return res.redirect('/login');
                        <br> }
                        <br> next();
                        <br>};
                        <br>alteração na rota POST de login, em users.js:
                        <br>router.post('/login', passport.authenticate('local', { failureFlash: true, failureRedirect:
                        '/login' }), catchAsync(async (req, res) =&gt; {
                        <br> req.flash('success', 'Welcome back!');
                        <br> const redirectUrl = req.session.returnTo || '/campgrounds';
                        <br> delete req.session.returnTo;
                        <br> res.redirect(redirectUrl);
                        <br>}));
                        <br>um detalhe extra: https://www.youtube.com/watch?v=g7SaXCYCgXU
                        <br>middleware.js:
                        <br>module.exports.isLoggedIn = (req, res, next) =&gt; {
                        <br> if (!req.isAuthenticated()) {
                        <br> req.flash('error', 'You must be signed in first!');
                        <br> return res.redirect('/login');
                        <br> }
                        <br> next();
                        <br>};
                        <br>app.js:
                        <br>app.use((req, res, next) =&gt; {
                        <br> if (!['/login', '/'].includes(req.originalUrl)) {
                        <br>req.session.returnTo = req.originalUrl;
                        <br> };
                        <br> res.locals.currentUser = req.user;
                        <br> res.locals.success = req.flash('success');
                        <br>res.locals.error = req.flash('error');
                        <br> next();
                        <br>});
                        <br>users.js:
                        <br>router.post('/login', passport.authenticate('local', { failureFlash: true, failureRedirect:
                        '/login' }), catchAsync(async (req, res) =&gt; {
                        <br> req.flash('success', 'Welcome back!');
                        <br> const redirectUrl = req.session.returnTo || '/campgrounds';
                        <br> delete req.session.returnTo;
                        <br> res.redirect(redirectUrl);
                        <br>}));
                    </p>
                    <h3>Basic Authorization</h3>
                    <p>
                        Vinculação de um usuário como autor aos campgrounds e reviews
                        <br>const CampgroundSchema = new Schema({
                        <br> title: String,
                        <br> image: String,
                        <br> price: Number,
                        <br> description: String,
                        <br> location: String,
                        <br> author: {
                        <br> type: Schema.types.ObjectId,
                        <br> ref: 'User'
                        <br> },
                        <br> reviews: [
                        <br> {
                        <br> type: Schema.Types.ObjectId,
                        <br> ref: 'Review'
                        <br> }
                        <br> ]
                        <br>});
                        <br>é necessário utilizar populate para o autor, assim como nos reviews
                        <br>router.get('/:id', catchAsync(async (req, res) =&gt; {
                        <br> const campground = await
                        Campground.findById(req.params.id).populate('reviews').populate('author');
                        <br> if (!campground) {
                        <br> req.flash('error', 'Cannot find that campground!');
                        <br> res.redirect('/campgrounds');
                        <br> };
                        <br> res.render('campgrounds/show', { campground });
                        <br>}));
                        <br>para exibir na página show ejs de campgrounds
                        <br>&lt;li class="list-group-item"&gt;Submited by
                        &lt;%=campground.author.username%&gt;&lt;/li&gt;
                        <br>é possível saber qual usuário está logado pela função isLoggedIn, e através dela é possível
                        adicionar um autor na criação de novos campgrounds, usando código na rota
                        <br>router.post('/', isLoggedIn, validateCampground, catchAsync(async (req, res, next) =&gt; {
                        <br> // if (!req.body.campground) throw new ExpressError('Invalid Campground', 400);
                        <br> const campground = new Campground(req.body.campground);
                        <br> campground.author = req.user._id;
                        <br> await campground.save();
                        <br> req.flash('success', 'Successfully made a new campground!');
                        <br> res.redirect(`/campgrounds/${campground._id}`);
                        <br>}));
                        <br>é possível esconder os botões de delete e edit caso o usuário conectado seja outro diferente
                        do autor do campground, usando no show ejs a lógica:
                        <br>&lt;%if (currentUser && campground.author.equals(currentUser._id)) {%&gt;
                        <br>dessa forma, ainda é possível usar métodos como atualizar a url e solicitações para
                        deletar/editar mesmo se não for o autor
                        <br>dessa maneira, é possível atualizar o código da rota bloqueando solicitações externas:
                        <br>router.put('/:id', isLoggedIn, validateCampground, catchAsync(async (req, res) =&gt; {
                        <br> const { id } = req.params;
                        <br> const campground = await Campground.findById(id);
                        <br> if (!campground.author.equals(req.user._id)) {
                        <br> req.flash('error', 'You do not have permission to do that!');
                        <br> return res.redirect(`/campgrounds/${id}`);
                        <br> };
                        <br> const campgroundUpdate = await Campground.findByIdAndUpdate(id, { ...req.body.campground
                        });
                        <br> req.flash('success', 'Successfully updated campground!');
                        <br> res.redirect(`/campgrounds/${campground._id}`);
                        <br>}));
                        <br>para evitar ter que duplicar esse código em todas as rotas em que for necessário a
                        autorização do usuário, o ideal é utilizar um middleware:
                        <br>const isAuthor = async (req, res, next) =&gt; {
                        <br> const { id } = req.params;
                        <br> const campground = await Campground.findById(id);
                        <br> if (!campground.author.equals(req.user._id)) {
                        <br> req.flash('error', 'You do not have permission to do that!');
                        <br> return res.redirect(`/campgrounds/${id}`);
                        <br> };
                        <br> next();
                        <br>};
                        <br>no arquivo de middleware, junto aos outros já inseridos anteriormente
                        <br>as rotas que estão utilizando o middleware são:
                        <br>router.get('/:id/edit', isLoggedIn, isAuthor, catchAsync(async (req, res) =&gt; { func }
                        <br>router.put('/:id', isLoggedIn, isAuthor, validateCampground, catchAsync(async (req, res)
                        =&gt; { func }
                        <br>router.delete('/:id', isLoggedIn, isAuthor, catchAsync(async (req, res) =&gt; { func }
                        <br>processo similar para adicionar o middleware nos reviews
                        <br>model review:
                        <br>const reviewSchema = new Schema({
                        <br> body: String,
                        <br> rating: Number,
                        <br> author: {
                        <br> type: Schema.Types.ObjectId,
                        <br> ref: 'User'
                        <br> }
                        <br>});
                        <br>campground show view
                        <br>&lt;%if(currentUser) {%&gt;
                        <br>o formulário de criação de um review só estará disponível caso algum usuário esteja
                        conectado
                        <br>dessa forma, igual no caso anterior, ainda é possível criar um review através de
                        solicitações forçadas
                        <br>router.get('/:id', catchAsync(async (req, res) =&gt; {
                        <br>const campground = await Campground.findById(req.params.id).populate({ path: 'reviews',
                        populate: { path: 'author' } }).populate('author');
                        <br>func
                        <br>}
                        <br>&lt;%if (currentUser && review.author.equals(currentUser._id)) {%&gt;
                        <br>&lt;h6 class="card-subtitle mb-2 text-muted"&gt;By
                        &lt;%=review.author.username%&gt;&lt;/h6&gt;
                        <br>middleware do review:
                        <br>module.exports.isReviewAuthor = async (req, res, next) =&gt; {
                        <br> const { id, reviewId } = req.params;
                        <br> const review = await Review.findById(reviewId);
                        <br> if (!review.author.equals(req.user._id)) {
                        <br> req.flash('error', 'You do not have permission to do that!');
                        <br> return res.redirect(`/campgrounds/${id}`);
                        <br> };
                        <br> next();
                        <br>};
                        <br>delete route de review, protegendo a rota de solicitações forçadas:
                        <br>router.delete('/:reviewId', isLoggedIn, isReviewAuthor, catchAsync(async (req, res) =&gt; {
                        func }
                    </p>
                    <h3>Controllers & Star Ratings</h3>
                    <p>
                        Model View Controller, basicamente pegar todo o código mais trabalhado e com certa
                        complexibilidade de entender, e colocar em arquivos separados, deixando os arquivos de rotas o
                        mais limpo e compreensível possível, é uma espécie de estruturação da aplicação
                        <br>diretório controllers
                        <br>campgrounds.js routes ficará então com o controller:
                        <br>const campgrounds = require('../controllers/campgrounds');
                        <br>e as rotas:
                        <br>router.get('/', catchAsync(campgrounds.index));
                        <br>router.get('/new', isLoggedIn, campgrounds.renderNewForm);
                        <br>router.get('/:id', catchAsync(campgrounds.showCampground));
                        <br>router.get('/:id/edit', isLoggedIn, isAuthor, catchAsync(campgrounds.renderEditForm));
                        <br>router.post('/', isLoggedIn, validateCampground, catchAsync(campgrounds.createCampground));
                        <br>router.put('/:id', isLoggedIn, isAuthor, validateCampground,
                        catchAsync(campgrounds.updateCampground));
                        <br>router.delete('/:id', isLoggedIn, isAuthor, catchAsync(campgrounds.deleteCampground));
                        <br>tudo que estava dentro de async (req, res) etc, estará dentro de campgrounds.js no diretório
                        controllers, deixando o código limpo
                        <br>a mesma coisa é feita em reviews e em users
                        <br>também é possível agrupar rotas de verbos diferentes de um mesmo caminho, usando
                        router.route:
                        <br>router.get('/new', isLoggedIn, campgrounds.renderNewForm);
                        <br> router.route('/')
                        <br> .get(catchAsync(campgrounds.index))
                        <br> .post(isLoggedIn, validateCampground, catchAsync(campgrounds.createCampground));
                        <br> router.route('/:id')
                        <br> .get(catchAsync(campgrounds.showCampground))
                        <br> .put(isLoggedIn, isAuthor, validateCampground,
                        catchAsync(campgrounds.updateCampground))
                        <br> .delete(isLoggedIn, isAuthor, catchAsync(campgrounds.deleteCampground));
                        <br>router.get('/:id/edit', isLoggedIn, isAuthor, catchAsync(campgrounds.renderEditForm));
                        <br>dessa forma, o ";" só pode ser colocado no último verbo das rotas, para não ter erros de
                        síntaxe, é necessário atenção nessa parte para não fazer erros internos na rota, como definir a
                        página de elementos que possuem id antes das outras, como :id e new
                        <br>o código acima é o de campgrounds, mas o mesmo é feito para as rotas de users, a de reviews
                        não é necessário, pois as rotas não são do mesmo caminho de url
                        <br>
                        <br>displaying star rating
                        <br>github documentation for starability - https://github.com/LunarLogic/starability
                        <br>arquivo basic dentro do diretório public/stylesheets com o nome de stars.css
                        <br>tudo no arquivo "show.ejs", a síntaxe está na documentação no github
                    </p>
                    <h3>Image Upload</h3>
                    <p>
                        a
                        <br>tipo do furmlário de new em campgrounds (enctype="multipart/form-data")
                        <br>input:file para imagens
                        <br>é necessário utilizar um middleware para manipular os dados dessa forma
                        <br>multer documentation on github - https://github.com/expressjs/multer
                        <br>npm i multer, em campgrounds.js:
                        <br>const multer = require('multer');
                        <br>const upload = multer({dest: 'uploads/'});
                        <br>
                        <br>.post(upload.single('image'), (req,res) => {
                        <br> res.send(req.body, req.file);
                        <br>})
                        <br>upload.array('image') (req.files) --- mais de um arquivo simultaneamente
                        <br>o arquivo é comprimido e salvo no diretório uploads
                        <br>não é recomendado associar credenciais diretamente no aplicativo
                        <br>.env documentation on github - https://github.com/motdotla/dotenv
                        <br>.env é um arquivo que não é compartilhado, fica localmente na máquina
                        <br>npm i dotenv
                        <br>arquivo .env no diretório raíz da aplicação. código para acessá-lo no app.js:
                        <br>if(proccess.env.NODE_ENV !== 'production') {
                        <br> require('dotenv').config();
                        <br> };
                        <br>no modo de desenvolvimento, é possível acessar .env, mas no produto, essas informações não
                        são adicionadas em um arquivo (environment variables)
                        <br>arquivo .env:
                        <br>CLOUDINARY_CLOUD_NAME=cloudinary_name
                        <br>CLOUDINARY_KEY=cloudinary_key
                        <br>CLOUDINARY_SECRET=cloudinary_secret
                        <br>no arquivo app então, é possível usar os valores definidos no .env em:
                        <br>process.env.cloudinary_name, process.env.cloudinary_key, process.env.cloudinary_secret
                        <br>uploading to cloudinary
                        <br>multer-storage-cloudinary documentation on github -
                        https://github.com/affanshahid/multer-storage-cloudinary
                        <br>npm i cloudinary multer-storage-cloudinary
                        <br>index.js, dentro do diretório cloudinary, contendo as configurações:
                        <br>const cloudinary = require('cloudinary').v2;
                        <br>const { CloudinaryStorage } = require('multer-storage-cloudinary');
                        <br> cloudinary.config({
                        <br> cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
                        <br> api_key: process.env.CLOUDINARY_KEY,
                        <br> api_secret: process.env.CLOUDINARY_SECRET
                        <br> });
                        <br> const storage = new CloudinaryStorage({
                        <br> cloudinary,
                        <br> params: {
                        <br> folder: 'YelpCamp',
                        <br> allowedFormats: ['jpeg', 'jpg', 'png'],
                        <br> }
                        <br> });
                        <br> module.exports = {
                        <br> cloudinary,
                        <br> storage
                        <br>}
                        <br>código para utilizar o cloudinary, em campgrounds.js route:
                        <br>const multer = require('multer');
                        <br>const { storage } = require('../cloudinary');
                        <br>const upload = multer({ storage });
                        <br>agora é possível fazer o upload das imagens, que fica disponível em um url informado no
                        objeto:
                        <br>[{"fieldname":"image","originalname":"img
                        1.jpg","encoding":"7bit","mimetype":"image/jpeg","path":"https://res.cloudinary.com/lucasneiva500/image/upload/v1647874024/b6cbpujatzlea5q2ihod.jpg","size":138310,"filename":"b6cbpujatzlea5q2ihod"}]
                        <br>o campground model agora ao inves de ter um image do tipo string, tem:
                        <br>images: [{
                        <br> url: String,
                        <br> filename: String
                        <br>}],
                        <br>campground route:
                        <br>.post(isLoggedIn, upload.array('image'), validateCampground,
                        catchAsync(campgrounds.createCampground));
                        <br>campground controller:
                        <br>campground.images = req.files.map(f => ({url: f.path, filename: f.filename}));
                        <br>como mudou o nome da imagem no modelo, também é necessárioa atualizar o as páginas ejs
                        <br>bootstrap carrousel
                        <br>estilização da página, função crud para imagens sincronizada com o cloudinary, etc
                        <br>
                        <br>não necessariamente utilizado (não faz diferença se usar ou não), aparentemente o bootstrap
                        já tem essa função incluída nele mesmo, menos a de mostrar o nome quando há mais de um arquivo
                        <br>bs-custom-file-input documentation - https://www.npmjs.com/package/bs-custom-file-input
                        <br>add script js in boilerplate, bsCustomFileInput.init() in validateForms.js, div with class
                        of custom-file, span with class of custom-file-label
                        <br>
                        <br>cloudinary crud to update/delete images with some features
                    </p>
                    <h3>Adding Maps</h3>
                    <p>
                        Mapbox
                        <br>Mapbox GL JS Documentation - https://docs.mapbox.com/mapbox-gl-js/api/
                        <br>Mapbox JS SDK Documentation - https://github.com/mapbox/mapbox-sdk-js
                        <br>Mapbox JS SDK Services Documentation - https://github.com/mapbox/mapbox-sdk-js/blob/main/docs/services.md
                        <br>use MAPBOX_TOKEN= token in .env file
                        <br>npm i @mapbox/mapbox-sdk
                        <br>código em campgrounds.js controller
                        <br>const mbxGeocoding = require('@mapbox/mapbox-sdk/services/geocoding');
                        <br>const mapBoxToken = process.env.MAPBOX_TOKEN;
                        <br>const geocoder = mbxGeocoding({accessToken: mapBoxToken});
                        <br>código para receber os dados de longitude, latitude, respectivamente
                        <br>const geoData = await geocoder.forwardGeocode({
                        <br> query: req.body.campground.location,
                        <br> limit: 1
                        <br> }).send();
                        <br> res.send(geoData.body.features[0].geometry.coordinates);
                        <br>mapbox gl js api reference - https://docs.mapbox.com/mapbox-gl-js/api/
                        <br>adicionar os scripts no boilerplate
                        <br>local, cordenadas, customizações visuais, etc
                    </p>
                    <h3>Fancy Cluster Map</h3>
                    <p>
                        Mapa global mostrando todos os pontos onde tem acampamentos
                        <br>cluster mapbox documentation - https://docs.mapbox.com/mapbox-gl-js/example/cluster/
                    </p>
                    <h3>Styles Clean Up</h3>
                    <p>
                        criação de estilo utilizando bootstrap e css para as views de users e campgrounds, removendo
                        inline styles etc
                        <br>adicionado controles para o mapa
                    </p>
                    <h3>Common Security Issues</h3>
                    <p>
                        <br>SQL injection and nonSQL injection
                        <br>users use the fields to search itens, for example, to close search query, and make their only codes, trying do delete/modify/add informations
                        <br>for example
                        <br>db.users.find({username: {"$gt": ""}});
                        <br>the code will find all users storaged in database
                        <br>this is a very simple example, but the mongo injection, or SQL injection follow this default
                        <br>potential issue to use the operators in querys with curly brases in nested objects, to manipulate the original querys
                        <br>a basic prevent to this is do not allow users to use dollar signs, or operators
                        <br>Express Mongoose Sanitize Documentation - https://www.npmjs.com/package/express-mongo-sanitize
                        <br>if user use ?&gt in url, an operator, to show data of site or another informations, we can block that with:
                        <br>const mongoSanitize = require('express-mongo-sanitize');
                        <br>app.use(mongoSanitize({replaceWith: '_'}));
                        <br>npm package, and using in this case, "_" as operator, blocking his functionality
                        <br>
                        <br>
                        <br>Cross-site scripting - injecting scripts in sites, retrieving users informations, vulnerability securities
                        <br>XSS Game - https://xss-game.appspot.com/
                        <br>in XSS game, play as the injector, is a good explain
                        <br>we can use express-validator in place of joi to block this
                        <br>Sanitize HTML Documentation - https://www.npmjs.com/package/sanitize-html
                        <br>Helmet Documentation - https://helmetjs.github.io/
                        <br>is important hide error stacks in client side in production, editing error.ejs
                        <br>helmet improves security to snite, XSS scripts, content security, etc
                        <br>helmet pode ser configurado para permitir/bloquear dados de fontes, evitando ataques nos dados
                    </p>
                    <h3>Deploying</h3>
                    <p>
                        MongoDB Cloud Services - https://www.mongodb.com/cloud
                        <br>Connect Mongo Documentation - https://www.npmjs.com/package/connect-mongo
                        <br>setting up the mongo atlas database
                        <br>create an account in mongodb
                        <br>create a database access
                        <br>whitelist the ip in network access
                        <br>use a cluster in the database
                        <br>connect database (connect your application)
                        <br>store the url in .env "DB_URL", overwriting the password following mongo instructions
                        <br>create a variable with the url, const dbUrl = process.env.DB_URL;
                        <br>change the data base connection of 'mongodb://127.0.0.1:27017/yelp-camp' to the dbUrl created
                        <br>now the application is using an online database, but the host continues local
                        <br>
                        <br>using mongo for store our session
                        <br>npm i connect-mongo@3
                        <br>Heroku - https://www.heroku.com/
                        <br>setting up heroku
                        <br>create an heroku account
                        <br>download and install the heroku command line interface
                        <br>heroku login in git bash
                        <br>heroku return an url
                        <br>.gitignore to node_modules and .env
                        <br>git remote -v in heroku CLI
                        <br>git add .
                        <br>git commit -m "ready to try deploying"
                        <br>git push heroku master
                        <br>
                        <br>
                        <br>fixing heroku errors
                        <br>heroku logs --tail
                        <br>package.json "scripts" "start": "node app.js"
                        <br>port
                        <br>const port = process.ebv.PORT || 3000;
                        <br>app.listen(port, () =&gt; {
                        <br>console.log(`Serving on port ${port}`)
                        <br>})
                        <br>
                        <br>configuring heroku environment variables
                        <br>config vars in heroku site settings
                        <br>all variables in .env needs to set in cloud, using the website or the CLI
                        <br>allow access from anywhere in mongodb atlas whitelist
                        <br>
                        <br>
                        <br>RandomKeygen - https://randomkeygen.com/
                        <br>YelpCamp by Colt Steele - https://github.com/Colt/YelpCamp/tree/3ef5c4ca6aae9243b28167db3c3fb0665c3ea46a
                    </p>
            </section>
            <hr>
            <section style="text-align: center; background-color: #9F3B7B;">
                <h2>The End, what's next</h2>
                <br><img src="img 2.png" alt="">
            </section>
            <hr>
        </div>
    </main>

    <footer>
        <a href="">About</a>
    </footer>

</body>

</html>